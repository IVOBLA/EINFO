
Du:
Wie kann ich alle adressen aus einem gebiet ermitteln
ChatGPT:
Das hÃ¤ngt etwas davon ab, was du mit â€žalle Adressen aus einem Gebietâ€œ genau meinst â€” also ob du ein Viertel, eine Gemeinde, eine Postleitzahl-Zone oder einen anderen Bereich meinst. Aber grundsÃ¤tzlich gibt es relativ gut etablierte Wege, um eine mÃ¶glichst vollstÃ¤ndige Adresse-Liste fÃ¼r ein Gebiet zu bekommen â€” insbesondere mit offenen Geodaten und Tools. Hier sind die wichtigsten AnsÃ¤tze (Stand: 30. 11. 2025, 10:00 MEZ) + worauf du achten solltest:

âœ… MÃ¶gliche Datenquellen und Methoden
OpenStreetMap (OSM) + Filter/Export
OSM enthÃ¤lt viele Adressdaten â€” StraÃŸen, Hausnummern etc. 
openstreetmap.at
+1

Mit Tools wie Overpass Turbo kannst du fÃ¼r ein beliebiges Gebiet (â€žAreaâ€œ) Abfragen formulieren, um alle GebÃ¤ude bzw. Adressen aus OSM zu extrahieren. 
OpenStreetMap Community Forum
+2
gis.stackexchange.com
+2

Das Resultat kannst du z. B. als XML/GeoJSON exportieren und dann nach CSV oder Excel umwandeln (fÃ¼r weitere Verarbeitung). 
journocode.com
+1

Diese Methode eignet sich besonders, wenn du ein spezifisches Gebiet (Stadtviertel, Gemeindegrenzen etc.) hast und open-source bzw. freie Daten wÃ¼nschst.

Vorteile: frei verfÃ¼gbar, oft sehr aktuell, relativ flexibel bezÃ¼glich Gebiet.
Nachteile: Abdeckung und VollstÃ¤ndigkeit variieren â€” nicht jede Adresse ist unbedingt vorhanden.

BEV / Ã–sterreichisches Adressregister
In Ã–sterreich gibt es ein offizielles Adressregister: das Ã–sterreichische Adressregister. Es enthÃ¤lt alle von Gemeinden offiziell vergebenen Adressen inklusive rÃ¤umlicher Koordinaten. 
Wikipedia
+1

Ãœber BEV (bzw. dessen Portal/Katasterservice) kÃ¶nnen diese Daten bezogen werden. 
bev.gv.at
+1

Das ist der zuverlÃ¤ssigste Weg, wenn du eine komplette, amtlich bestÃ¤tigte Adressliste eines Gebietes willst â€” z. B. Gemeinde, Bezirk oder Bundesland.

Vorteile: VollstÃ¤ndigkeit, amtliche DatenqualitÃ¤t, rechtlicher RÃ¼ckhalt.
Nachteile: Evtl. FormalitÃ¤ten/Zugangsregeln bei sehr groÃŸen Gebieten; manchmal etwas unÃ¼bersichtlicher Einstieg als â€žeinfacher OSM-Exportâ€œ.

DatensÃ¤tze aus offenen Global- oder Ã¶ffentlichen Datenbanken, z. B. OpenAddresses
OpenAddresses sammelt weltweit Adressdaten und stellt sie als offenen Datensatz zur VerfÃ¼gung â€” inklusive StraÃŸenname, Hausnummer, PLZ, Koordinaten. 
OpenAddresses
+2
placekey.io
+2

FÃ¼r viele Regionen kann das eine gute Startbasis sein, insbesondere wenn man schnell und ohne groÃŸen Aufwand eine grÃ¶ÃŸere Adresse-Grundlage will.

Vorteile: Einfacher Zugang, global verfÃ¼gbar, gut fÃ¼r erste Analyse oder PrÃ¼fung.
Nachteile: Abdeckung und AktualitÃ¤t variieren je nach Region; evtl. nicht vollstÃ¤ndig.

ðŸ› ï¸ Praktischer Workflow â€” Beispiel mit OSM / Overpass
Wenn du z. B. alle Adressen eines Wiener Bezirks oder einer Gemeinde extrahieren willst, kÃ¶nnte der Ablauf so aussehen:

Ã–ffne Overpass Turbo â†’ definiere das gewÃ¼nschte Gebiet (z. B. via Polygon, Bounding-Box oder Gemeinde-Name).

Stelle eine Overpass-Abfrage, die nach â€žaddr:streetâ€œ + â€žaddr:housenumberâ€œ (und optional PLZ, Ort) filtert.

Exportiere das Ergebnis als GeoJSON oder XML.

Optional: Mit einem Skript oder GIS-Tool (z. B. mit QGIS oder mit Python) in ein tabellarisches Format wie CSV konvertieren.

In deiner eigenen Datenbank oder Datei abspeichern und bei Bedarf weiter verarbeiten.

Wenn du in Ã–sterreich bist und eine mÃ¶glichst vollstÃ¤ndige, amtliche Liste willst, kannst du alternativ das Adressregister vom BEV verwenden â€” je nach Umfang auch automatisiert via API oder Download-File (sofern verfÃ¼gbar).

âš ï¸ Wichtige Hinweise / Grenzen
VollstÃ¤ndigkeit: Keine Datenquelle ist perfekt â€” OSM kann unvollstÃ¤ndig sein, Ã¶ffentliche DatensÃ¤tze wie OpenAddresses und selbst amtliche Register kÃ¶nnen zeitliche LÃ¼cken haben oder VerzÃ¶gerungen bei Aktualisierung.

Rechte & Lizenz / Datenschutz: Gerade wenn du Adressen weiterverarbeitest (z. B. fÃ¼r Analyse, Mailings etc.), musst du prÃ¼fen, ob und wie du die Daten nutzen darfst (Lizenz, Datenschutz, Zweck).

Gebietsgrenzen definieren: Wenn dein â€žGebietâ€œ z. B. keine offizielle Gemeinde ist (z. B. ein unregelmÃ¤ÃŸiges Polygon), musst du bei der Abfrage sorgfÃ¤ltig arbeiten â€” Tools wie Overpass ermÃ¶glichen das, andere Datenquellen evtl. nicht.

Datenformat & Nachverarbeitung: Raw-Exporte (GeoJSON, XML) sind selten â€žschon fertig fÃ¼r Excelâ€œ â€” meistens ist Nachbearbeitung nÃ¶tig (Filtern, Parsen, Validieren, Normalisieren).

ðŸŽ¯ Meine EinschÃ¤tzung: Was du am besten verwendest â€” je nach Ziel
Ziel / Wunsch	Empfohlene Methode / Quelle
Komplette, amtlich bestÃ¤tigte Adressliste auf Gemeinde-/Stadt-/Bundesland-Ebene in Ã–sterreich	Ã–sterreichisches Adressregister (BEV)
Relativ schnelle, offene, flexible Adressliste fÃ¼r ein beliebiges Gebiet (z. B. Stadtviertel, Polygon, Bereich)	OpenStreetMap + Overpass / QGIS / Export
Einfacher Einstieg oder globale Adressen als Basis (nicht unbedingt vollstÃ¤ndig)	OpenAddresses
Kombination aus rÃ¤umlichen Daten und GIS-Verarbeitung (z. B. analoge Verarbeitung mit deinen Wetterprojekten)	OSM-Export â†’ QGIS oder Python/PostGIS
Wenn du willst: ich kann dir direkt ein kleines Skript in Python schreiben, mit dem du alle adress-relevanten Daten (StraÃŸe, Hausnummer, Koordinaten) fÃ¼r ein definiertes Polygon (z. B. dein Gebiet in Wien oder KÃ¤rnten) aus OSM exportieren kannst â€” inklusive Speichern als CSV/GeoJSON.
MÃ¶chtest du so ein Skript â€” und falls ja: soll das fÃ¼r Austria allgemein oder fÃ¼r ein konkretes Gebiet (z. B. Wien) sein?

Du:
Mit open street map
ChatGPT:

Nachgedacht fÃ¼r 6s
Okay, machen wirâ€™s konkret mit OpenStreetMap. ðŸ˜Š
(Stand: 30.11.2025, 14:00 Uhr)

Ich zeig dir zwei Wege:

Mit Overpass Turbo im Browser (schnell + ohne Programmierung)

Mit einem fertigen Overpass-Query, das du an dein Gebiet anpassen kannst

Ich schreibe es so, dass du es z. B. fÃ¼r Gemeinde Feldkirchen oder jedes andere Gebiet verwenden kannst.

1ï¸âƒ£ Overpass Turbo â€“ alle Adressen im Gebiet holen
Overpass Turbo Ã¶ffnen
Gehe auf: https://overpass-turbo.eu

Gebiet auswÃ¤hlen
Oben im MenÃ¼:

Wizard klicken â†’ dort z. B. eingeben:
name=Feldkirchen

Dann auf Build and run query.

Auf der Karte siehst du jetzt das Gebiet, aber noch nicht deine gewÃ¼nschte Abfrage.

Query ersetzen durch Adress-Abfrage

Klicke oben auf â€œEditâ€ und lÃ¶sche den Inhalt. FÃ¼ge dann z. B. diese Abfrage ein:

[out:json][timeout:180];

// 1. Gebiet nach Name suchen (z.B. Gemeinde Feldkirchen)
area["name"="Feldkirchen"]["boundary"="administrative"]["admin_level"="8"]->.searchArea;

// 2. Alle Objekte mit Adress-Tags in dieser Area holen
(
  node["addr:housenumber"](area.searchArea);
  way["addr:housenumber"](area.searchArea);
  relation["addr:housenumber"](area.searchArea);
);

out body;
>;
out skel qt;
Anpassen fÃ¼r andere Gebiete:

"Feldkirchen" â†’ z. B. "Villach" oder "Wiener Neustadt"

admin_level:

8 = Gemeinde

6 = Bezirk

4 = Bundesland

Query ausfÃ¼hren

Auf â€œRunâ€ klicken.

Wenn alles passt, siehst du auf der Karte viele Punkte/Objekte â€“ das sind die Adressen.

Exportieren

Oben auf Export â†’ z. B.:

â€œDownload / raw dataâ€ â†’ JSON/OSM

oder GeoJSON (praktisch fÃ¼r QGIS oder eigene Skripte)

Wenn du CSV willst:

Entweder in QGIS Ã¶ffnen und als CSV exportieren

oder ein kleines Script schreiben (kann ich dir machen), das JSON â†’ CSV umwandelt.

2ï¸âƒ£ GebÃ¤ude + Adress-Daten (statt nur Adress-Nodes)
Viele Adressen hÃ¤ngen direkt an GebÃ¤uden. DafÃ¼r:

[out:json][timeout:180];

// Gebiet definieren
area["name"="Feldkirchen"]["boundary"="administrative"]["admin_level"="8"]->.searchArea;

// GebÃ¤ude mit addr:* im Gebiet
(
  way["building"]["addr:housenumber"](area.searchArea);
  relation["building"]["addr:housenumber"](area.searchArea);
);

out body;
>;
// Geometrie ausgeben (GebÃ¤ude-Umrisse)
out skel qt;
Damit bekommst du GebÃ¤ude + Adresse (StraÃŸe, Hausnummer, PLZ, Ort, wenn gepflegt).

3ï¸âƒ£ Typische Probleme (falls â€žOverpass liefert keine Datenâ€œ)
Wenn du nichts bekommst, liegt es meistens an:

Gebietsdefinition falsch

Der Name ist anders (z. B. â€žFeldkirchen in KÃ¤rntenâ€œ statt nur â€žFeldkirchenâ€œ).

LÃ¶sung: Statt "name"="Feldkirchen" genauer:

area["name"="Feldkirchen in KÃ¤rnten"]["boundary"="administrative"]["admin_level"="8"]->.searchArea;
Falsches admin_level

Manche Gemeinden sind als admin_level 8, Bezirke 6, BundeslÃ¤nder 4, StÃ¤dte manchmal anders.

Im Zweifel kannst du zuerst eine Debug-Abfrage machen:

[out:json][timeout:60];
relation["name"="Feldkirchen"];
out body;
>;
out skel qt;
Im Ergebnis siehst du, welche Relation passt (inkl. admin_level).

Gebiet hat tatsÃ¤chlich sehr wenige Adressdaten in OSM

Dann kommen halt nur wenige oder keine EintrÃ¤ge â€“ liegt an der OSM-Abdeckung, nicht an deinem Query.

4ï¸âƒ£ Adressen in ein sauberes Tabellenformat bringen
Wenn du z. B. die JSON-Rohdaten hast, kannst du daraus z. B. so eine Tabelle machen:

ID

Typ (node/way/relation)

StraÃŸe (addr:street)

Hausnummer (addr:housenumber)

PLZ (addr:postcode)

Ort (addr:city oder addr:place)

LÃ¤ngengrad (lon)

Breitengrad (lat)

Ich kann dir bei Bedarf ein fertiges Python-Script basteln, das:

eine Overpass-Abfrage ausfÃ¼hrt (fÃ¼r dein Gebiet),

alle Adress-Nodes/Ways einsammelt,

daraus eine CSV-Datei schreibt (z. B. adressen_feldkirchen.csv).

5ï¸âƒ£ Was ich als NÃ¤chstes fÃ¼r dich tun kann
Wenn du magst, mache ich dir direkt eins von diesen Dingen:

âœ… Konkrete Overpass-Abfrage exakt fÃ¼r â€žGemeinde Feldkirchenâ€œ (oder ein anderes Gebiet, das du nennst)

âœ… Ein Python-Script, das:

den Overpass-Server abfragt und

dir eine fertige CSV mit allen Adressen erzeugt

Schreib mir einfach kurz:

FÃ¼r welches Gebiet genau (z. B. â€žGemeinde Feldkirchen in KÃ¤rntenâ€œ oder â€žPolygon / Bounding Boxâ€œ)

Und ob du lieber nur Adresspunkte willst oder GebÃ¤ude + Adressen.

Du:
Ohne overpass
ChatGPT:
Ja â€” du kannst auch ohne Overpass Turbo / Overpass API auf OpenStreetMap-Daten zugreifen und alle Adressen eines Gebiets ziehen. Hier sind ein paar alternative Wege + Vor-/Nachteile. (Stand: 30.11.2025, 14:20 Uhr)

âœ… Wie ohne Overpass: alternative Wege
â€¢ Kompletten OSM-Datenausschnitt herunterladen
Du kannst statt einer API-Abfrage einen Daten-â€žExtractâ€œ des OSM-Datensatzes herunterladen â€” z. B. Ã¼ber Dienste wie Geofabrik oder BBBike. 
Geoapify
+2
learnosm.org
+2

Diese Dateien enthalten alle Daten (Nodes, Ways, Relations) eines grÃ¶ÃŸeren Gebietes (Land, Region oder Landesteil) in Formaten wie PBF oder XML. 
Geoapify
+2
wiki.openstreetmap.org
+2

Danach kannst du lokal mit GIS-Tools oder Script-Workflows aus der Rohdatei alle Objekte mit Adress-Tags (z. B. addr:street, addr:housenumber etc.) herausfiltern â€” also Adressen extrahieren.

â€¢ GIS-Tools / Desktop-Tools nutzen
Tools wie Osmosis oder osmfilter (oder GIS-Software wie QGIS + ggf. weitere Plugins) kÃ¶nnen solche (â€žrohenâ€œ) OSM-Daten verarbeiten, filtern und z. B. in CSV, GeoJSON oder Shapefiles wandeln â€” damit kannst du eine Adressliste generieren. 
gis.stackexchange.com
+2
learnosm.org
+2

Das Vorgehen:

Download des passenden OSM-Extracts (fÃ¼r dein Land oder Region).

Filter auf Adress-Tags (z. B. HÃ¤user / GebÃ¤ude mit addr:*).

Export der relevanten Objekte mit Geometrie und Adress-Tags in ein fÃ¼r dich brauchbares Datenformat.

â€¢ Alternative Dienste / APIs, die OSM-Daten bereitstellen
Es existieren auch APIs und Dienste, die OSM-Daten abstrahieren und bereitstellen â€” mit fertiger Abfrage und Filterung, ohne dass du Overpass-QL schreiben musst. 
Geoapify
+1

Diese Dienste sind zwar meist einfacher zu handhaben, kÃ¶nnen aber lizenz-, usage- oder kostenbedingt eingeschrÃ¤nkt sein.

âš ï¸ Vorteile & Nachteile der â€žOhne-Overpassâ€œ-AnsÃ¤tze
âœ… Vorteile	âš ï¸ Nachteile
Keine Notwendigkeit, Overpass-QL zu lernen / keine Rate-Limits / keine API-Timeouts	Download groÃŸer Dateien (je nach Gebiet), evtl. unnÃ¶tig viele Daten â€” hoher Speicher- und Rechenaufwand
Voller Zugriff auf alle OSM-Daten (nicht nur gefiltert) â€” bietet maximale FlexibilitÃ¤t	Existierende Daten (z. B. Adress-Tags) mÃ¼ssen ggf. nachbearbeitet / gefiltert werden â€” aufwendiger Workflow
Gute Kontrolle fÃ¼r eigene Datenpipelines, automatisierte Verarbeitung, Backup, Versionierung	Aufwand vs. Komfort: FÃ¼r einzelne Abfragen kann Overpass leichter sein als erst Download + Filterung
ðŸŽ¯ EinschÃ¤tzung: Wann welcher Ansatz passt
Wenn du ein kleines Gebiet oder nur ein paar Hundert Adressen brauchst â†’ Overpass (oder API-Dienste) sind meist unkomplizierter.

Wenn du aber groÃŸflÃ¤chig arbeitest (z. B. ganz Bundesland, ganz Ã–sterreich, groÃŸe Gebiete) oder Backups / eigene Datenbasis willst â†’ Download + lokale Verarbeitung ist robuster und nachhaltiger.

Wenn du automatisiert analysieren willst (z. B. fÃ¼r ein Script, GIS-Pipeline, Datenbank) â€” ist der â€žOffline-Wegâ€œ meist sinnvoller.

ðŸ’¡ Empfehlung: FÃ¼r dein Umfeld (Wetter-/GIS-Projekte) wÃ¼rde ich so vorgehen
Da du sowieso mit GIS / Geodaten arbeitest und vermutlich grÃ¶ÃŸere Gebiete betrachtest:

Lade per Geofabrik oder BBBike einen passenden OSM-Auszug fÃ¼r dein Bundesland oder Region (z. B. KÃ¤rnten, ganz Ã–sterreich).

Verwende ein Script oder Osmosis / osmfilter, um alle GebÃ¤ude/Adressen mit addr:* zu extrahieren.

Speichere das Ergebnis als CSV, GeoJSON oder in deiner Datenbank â€” dann kannst du sie mit deinem Wetter-/Tracking-Workflow verbinden.

Wenn du willst â€” kann ich ein Beispiel-Python-Script schreiben, das genau diesen Ablauf fÃ¼r dich umsetzt â€” also: OSM-PBF-Datei einlesen â†’ adress-relevante Objekte filtern â†’ CSV erzeugen. Dann kannst du es direkt in deinem Projekt einsetzen. MÃ¶chtest du das so?

Du:
Bezirk feldkirche
ChatGPT:

Nachgedacht fÃ¼r 6s
Perfekt, dann machen wir: alle Adressen fÃ¼r den Bezirk Feldkirchen, basierend auf OpenStreetMap â€“ ohne Overpass, dafÃ¼r mit lokaler Verarbeitung.
(Stand: 30.11.2025, 14:30 Uhr)

Ich zeige dir:

Welchen Datenausschnitt du brauchst

Wie du Bezirk Feldkirchen daraus herausfilterst

Ein Beispiel-Workflow mit Tools oder Python-Script

1ï¸âƒ£ OSM-Daten herunterladen (statt Overpass)
Am einfachsten: du nimmst einen OSM-Auszug fÃ¼r KÃ¤rnten bzw. Ã–sterreich (PBF-Datei). Typischer Weg:

Region â€žAustriaâ€œ â†’ PBF herunterladen (z. B. austria-latest.osm.pbf)

Alternativ: nur â€žCarinthia/KÃ¤rntenâ€œ falls es einen Unter-Auszug gibt

(Die genauen Download-Links nenne ich dir nicht direkt hier als URL-Text, wegen Format-Regeln â€“ aber du kennst sicher Geofabrik & Co; sonst sag ich dir, wonach du suchen musst.)

2ï¸âƒ£ Bezirk Feldkirchen rÃ¤umlich ausclippen
Du brauchst die Boundary vom Bezirk Feldkirchen als Polygon:

Entweder als OSM-Boundary (Relation â€žBezirk Feldkirchenâ€œ)

oder als Shapefile/GeoJSON z. B. aus offenen Verwaltungsgrenzen (z. B. Statistik Austria / OpenData)

Dann hast du:

austria-latest.osm.pbf (oder KÃ¤rnten-Auszug)

bezirk_feldkirchen_boundary.geojson (oder Shapefile)

3ï¸âƒ£ Adressen filtern â€“ zwei typische Wege
Variante A: GIS-Tool (QGIS) â€“ mehr klicken, wenig programmieren
PBF nach QGIS laden

QGIS kann direkt OSM-PBF Ã¶ffnen.

OSM-Daten werden in Layer wie â€žPointsâ€œ, â€žLinesâ€œ, â€žMultilinesâ€œ, â€žMultipolygonsâ€œ aufgeteilt.

Adress-Objekte herausfiltern

In den Attributen nach Feldern wie addr:housenumber, addr:street, addr:postcode, addr:city filtern.

Du kannst z. B. in der Abfrage sagen:

â€œaddr:housenumberâ€ IS NOT NULL

Clipping auf Bezirk Feldkirchen

Boundary-Layer von Bezirk Feldkirchen laden.

Geoverarbeitung â†’ â€žVektorenâ€œ â†’ â€žClipâ€œ:

Eingabelayer: Adress-Punkte/-GebÃ¤ude

Clip-Layer: Bezirks-Polygon

Ergebnis = nur Adressen im Bezirk.

Export als Tabelle

Ergebnis-Layer â†’ â€žExportieren â†’ Als CSV speichernâ€œ

Spalten z. B.: StraÃŸe, Hausnummer, PLZ, Ort, LÃ¤ngengrad, Breitengrad.

Fertig: du hast eine CSV mit allen OSM-Adressen im Bezirk Feldkirchen.

Variante B: Script-basiert (Python) â€“ fÃ¼r Automation / wiederkehrende LÃ¤ufe
FÃ¼r dich vermutlich spannender, weil du eh schon viel mit Python/GIS machst.

Grobe Idee:

Mit osmium oder pyosmium PBF einlesen und alle Objekte mit addr:housenumber extrahieren.

Zu jedem Objekt Koordinaten bestimmen (bei Nodes direkt, bei Ways/Polygons z. B. Schwerpunkt).

Boundary â€žBezirk Feldkirchenâ€œ als GeoJSON laden.

Mit shapely prÃ¼fen: Punkt liegt innerhalb vom Bezirks-Polygon?

Treffer in eine CSV schreiben.

Wenn du willst, schreibe ich dir im nÃ¤chsten Schritt ein konkretes Python-Script (inkl. Requirements), das:

austria-latest.osm.pbf einliest,

bezirk_feldkirchen.geojson lÃ¤dt,

alle Adressen im Bezirk findet,

und als adressen_bezirk_feldkirchen.csv speichert.

Dazu musst du mir nur noch sagen, ob du:

ðŸ§­ Linux oder Windows als Zielsystem verwenden willst (fÃ¼r Pfade), und

ob du schon mit Python + pip am System arbeitest (was bei dir ziemlich sicher â€žjaâ€œ ist ðŸ˜‰).

Wenn du keine Lust auf Script hast, kÃ¶nnen wir auch Schritt-fÃ¼r-Schritt QGIS machen.

Du:
Mit node js
ChatGPT:

Nachgedacht fÃ¼r 12s
Alles klar, machen wir das mit Node.js, komplett ohne Overpass zur Laufzeit.
(Stand: 30.11.2025, 14:40 Uhr)

Ich zeige dir:

Welche Dateien du brauchst

Welche npm-Pakete du installierst

Ein fertiges Node-Script, das aus austria-latest.osm.pbf alle Adressen im Bezirk Feldkirchen herausfiltert und als CSV speichert

1ï¸âƒ£ Daten, die du einmalig besorgen musst
1. OSM-PBF fÃ¼r Ã–sterreich (oder KÃ¤rnten)
Lade dir z. B.:

austria-latest.osm.pbf

in ein Verzeichnis, z. B.:

D:\osm\austria-latest.osm.pbf     # Windows-Beispiel
/home/bfkdo/osm/austria-latest.osm.pbf  # Linux-Beispiel
2. Polygon vom Bezirk Feldkirchen als GeoJSON
Du brauchst ein File, z. B.:

bezirk_feldkirchen.geojson
Das ist ein Polygon/Multipolygon mit der Bezirksgrenze.
Wie du das genau erzeugst (z. B. aus Verwaltungsgrenzen, OSM-Boundary, Statistik Austria) kannst du einmalig extern machen. FÃ¼r das Script ist nur wichtig: es ist ein valides GeoJSON-Polygon mit WGS84-Koordinaten.

2ï¸âƒ£ Node.js: benÃ¶tigte Pakete
In einem neuen Projektordner:

mkdir feldkirchen-adressen
cd feldkirchen-adressen
npm init -y
npm install node-osmium @turf/turf csv-writer
node-osmium â†’ liest/streamt .osm.pbf

@turf/turf â†’ Geo-Operationen (Punkt-in-Polygon)

csv-writer â†’ CSV-Datei schreiben

3ï¸âƒ£ Node-Script: extract-feldkirchen-addresses.mjs
Erzeuge eine Datei extract-feldkirchen-addresses.mjs:

import fs from 'fs';
import osmium from 'node-osmium';
import * as turf from '@turf/turf';
import { createObjectCsvWriter } from 'csv-writer';

// === KONFIGURATION ===
const PBF_FILE = 'D:/osm/austria-latest.osm.pbf';           // Pfad anpassen!
const BOUNDARY_FILE = './bezirk_feldkirchen.geojson';       // Pfad anpassen!
const OUTPUT_CSV = './adressen_bezirk_feldkirchen.csv';

// === 1. Bezirks-Grenze laden (GeoJSON) ===
const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, 'utf8'));

// Falls das GeoJSON mehrere Features enthÃ¤lt, das erste nehmen:
let boundaryFeature;
if (boundaryGeojson.type === 'FeatureCollection') {
  boundaryFeature = boundaryGeojson.features[0];
} else if (boundaryGeojson.type === 'Feature') {
  boundaryFeature = boundaryGeojson;
} else {
  throw new Error('Unerwartetes GeoJSON-Format fÃ¼r Boundary.');
}

const boundaryPolygon = turf.feature(boundaryFeature.geometry);

// === 2. CSV-Writer vorbereiten ===
const csvWriter = createObjectCsvWriter({
  path: OUTPUT_CSV,
  header: [
    { id: 'osm_id', title: 'OSM_ID' },
    { id: 'osm_type', title: 'OSM_TYPE' },
    { id: 'street', title: 'STRASSE' },
    { id: 'housenumber', title: 'HAUSNUMMER' },
    { id: 'postcode', title: 'PLZ' },
    { id: 'city', title: 'ORT' },
    { id: 'lat', title: 'LAT' },
    { id: 'lon', title: 'LON' }
  ]
});

// Zwischenspeicher fÃ¼r CSV-EintrÃ¤ge (wird regelmÃ¤ÃŸig geleert)
const buffer = [];
const BUFFER_LIMIT = 5000;

// === 3. Hilfsfunktion: Punkt aus Node/Way berechnen ===
function getPointFromOSMObject(obj) {
  if (obj.type === 'node') {
    const lon = obj.lon;
    const lat = obj.lat;
    if (typeof lon === 'number' && typeof lat === 'number') {
      return turf.point([lon, lat]);
    }
  }

  // FÃ¼r Ways / Beziehungen -> Schwerpunkt
  if (obj.type === 'way') {
    // Liste der Knoten-Koordinaten holen
    const coords = obj.node_coords()
      .map(nc => [nc.lon, nc.lat])
      .filter(c => typeof c[0] === 'number' && typeof c[1] === 'number');

    if (coords.length > 0) {
      // Geometrie als Polygon oder LineString approximieren; hier: MultiPoint -> Mittelpunkt
      const multipoint = turf.multiPoint(coords);
      const centroid = turf.centroid(multipoint);
      return centroid;
    }
  }

  // FÃ¼r einfache Zwecke ignorieren wir Relations oder behandeln sie spÃ¤ter
  return null;
}

// === 4. Adress-Tags auslesen ===
function extractAddressTags(tags) {
  const street = tags['addr:street'] || '';
  const housenumber = tags['addr:housenumber'] || '';
  const postcode = tags['addr:postcode'] || '';
  const city = tags['addr:city'] || tags['addr:place'] || '';

  // Nur relevante Adressen behalten (mind. Hausnummer)
  if (!housenumber) {
    return null;
  }

  return { street, housenumber, postcode, city };
}

// === 5. PBF einlesen und filtern ===

console.log(`[${new Date().toISOString()}] Starte Verarbeitung von ${PBF_FILE} ...`);

const reader = new osmium.Reader(PBF_FILE);
const handler = new osmium.Handler();

// NODEs mit addr:housenumber
handler.on('node', node => {
  const addr = extractAddressTags(node.tags());
  if (!addr) return;

  const pt = getPointFromOSMObject(node);
  if (!pt) return;

  if (turf.booleanPointInPolygon(pt, boundaryPolygon)) {
    buffer.push({
      osm_id: node.id,
      osm_type: 'node',
      street: addr.street,
      housenumber: addr.housenumber,
      postcode: addr.postcode,
      city: addr.city,
      lat: pt.geometry.coordinates[1],
      lon: pt.geometry.coordinates[0]
    });

    if (buffer.length >= BUFFER_LIMIT) {
      reader.pause();
      csvWriter.writeRecords(buffer.splice(0, buffer.length))
        .then(() => {
          console.log(`[${new Date().toISOString()}] ${BUFFER_LIMIT} EintrÃ¤ge in CSV geschrieben (Nodes).`);
          reader.resume();
        })
        .catch(err => {
          console.error('Fehler beim Schreiben der CSV (Nodes):', err);
          process.exit(1);
        });
    }
  }
});

// WAYs mit addr:housenumber (z. B. GebÃ¤ude)
handler.on('way', way => {
  const addr = extractAddressTags(way.tags());
  if (!addr) return;

  const pt = getPointFromOSMObject(way);
  if (!pt) return;

  if (turf.booleanPointInPolygon(pt, boundaryPolygon)) {
    buffer.push({
      osm_id: way.id,
      osm_type: 'way',
      street: addr.street,
      housenumber: addr.housenumber,
      postcode: addr.postcode,
      city: addr.city,
      lat: pt.geometry.coordinates[1],
      lon: pt.geometry.coordinates[0]
    });

    if (buffer.length >= BUFFER_LIMIT) {
      reader.pause();
      csvWriter.writeRecords(buffer.splice(0, buffer.length))
        .then(() => {
          console.log(`[${new Date().toISOString()}] ${BUFFER_LIMIT} EintrÃ¤ge in CSV geschrieben (Ways).`);
          reader.resume();
        })
        .catch(err => {
          console.error('Fehler beim Schreiben der CSV (Ways):', err);
          process.exit(1);
        });
    }
  }
});

// === 6. Verarbeitung starten ===
osmium.apply(reader, handler);

// === 7. Ende: restlichen Buffer schreiben ===
reader.on('end', () => {
  console.log(`[${new Date().toISOString()}] PBF-Datei vollstÃ¤ndig gelesen, schreibe Rest-Buffer ...`);

  if (buffer.length > 0) {
    csvWriter.writeRecords(buffer)
      .then(() => {
        console.log(`[${new Date().toISOString()}] Fertig. Adressen gespeichert in: ${OUTPUT_CSV}`);
      })
      .catch(err => {
        console.error('Fehler beim Schreiben der letzten CSV-EintrÃ¤ge:', err);
      });
  } else {
    console.log('Keine Adressen im Buffer, nichts mehr zu schreiben.');
  }
});
Wichtig: Pfade zu PBF_FILE und BOUNDARY_FILE oben an dein System anpassen.

Starten:

node extract-feldkirchen-addresses.mjs
Danach solltest du eine Datei haben:

adressen_bezirk_feldkirchen.csv
mit Spalten:

OSM_ID, OSM_TYPE

STRASSE, HAUSNUMMER, PLZ, ORT

LAT, LON

4ï¸âƒ£ Was du ggf. noch tun musst
Falls node-osmium bei der Installation meckert, brauchst du Build-Tools (C++-Compiler, libosmium-Dependencies). Unter Windows am besten â€žBuild Tools for Visual Studioâ€œ, unter Linux die Ã¼blichen build-essential, cmake usw.

Wenn dein bezirk_feldkirchen.geojson mehrere Features enthÃ¤lt, kannst du das Script leicht erweitern, um alle zu mergen â€“ aktuell nimmt es das erste Feature.

Wenn du magst, kann ich dir im nÃ¤chsten Schritt noch:

ein Beispiel-bezirk_feldkirchen.geojson-Skeleton zeigen (wie der Aufbau aussehen muss),

oder das Script erweitern (z. B. Logging, Fortschrittsanzeige, Filter fÃ¼r bestimmte Orte/PLZ).

Du:
Osm pbf fÃ¼r Ã¶sterreich
ChatGPT:

Nachgedacht fÃ¼r 5s
Kurz & knackig (Stand: 30.11.2025, ~15:00 Uhr):

ðŸ—ºï¸ Wo bekommst du austria-latest.osm.pbf her?
Variante 1 â€“ Geofabrik (Standardquelle)

Geh auf die Europa-Ãœbersicht der Geofabrik-Downloads.

In der Liste der LÃ¤nder auf â€œAustriaâ€ klicken.

Dort findest du eine Datei namens z. B. austria-251127.osm.pbf (Datum Ã¤ndert sich tÃ¤glich).

Die lÃ¤dst du runter und speicherst sie z. B. als:

D:\osm\austria-latest.osm.pbf
oder unter Linux:

/home/bfkdo/osm/austria-latest.osm.pbf
Geofabrik aktualisiert die Austria-PBF tÃ¤glich, d. h. du hast eine fast tagesaktuelle OSM-Grundlage.

Variante 2 â€“ Nur KÃ¤rnten statt ganz AT (kleiner & schneller)

Wenn du Speicher/Performance sparen willst, kannst du auch gleich den KÃ¤rnten-Auszug nehmen, z. B.:

karnten-latest.osm.pbf von einem OSM-Mirror, der Ã–sterreich nach BundeslÃ¤ndern gesplittet anbietet.

Der Workflow mit deinem Node-Script bleibt derselbe, du Ã¤nderst nur:

const PBF_FILE = '/pfad/zu/karnten-latest.osm.pbf';
Variante 3 â€“ Individuelle Ausschnitte (BBBike)

FÃ¼r kleinere Gebiete (z. B. nur â€žRaum Feldkirchenâ€œ) kannst du dir auch Ã¼ber BBBike Extracts einen maÃŸgeschneiderten PBF-Ausschnitt erzeugen.

FÃ¼r dein Feldkirchen-Adress-Script wÃ¼rde ich entweder:

KÃ¤rnten-PBF nehmen (reicht bequem fÃ¼r Bezirk Feldkirchen), oder

gleich ganz Austria-PBF, wenn du spÃ¤ter noch andere Bezirke auswerten willst.

Wenn du willst, passe ich dir das Node-Script oben direkt auf karnten-latest.osm.pbf + einen einfachen Boundary-Check fÃ¼r Bezirk Feldkirchen an.

Du:
Woher bekomme ich das pbf
ChatGPT:
Hier â€” du kannst das PBF ganz einfach herunterladen. Eine der gebrÃ¤uchlichsten Quellen:

âœ… Einfacher Download von Geofabrik
Gehe auf die Seite von Geofabrik fÃ¼r Ã–sterreich. 
Geofabrik Download Server

Dort findest du die Datei austria-latest.osm.pbf. 
Geofabrik Download Server

Diese Datei enthÃ¤lt die kompletten OSM-Rohdaten fÃ¼r Ã–sterreich â€” genau passend fÃ¼r deinen Zweck.

Das heiÃŸt im Klartext: du klickst â†’ herunterladen â†’ speicherst sie lokal (z. B. austria-latest.osm.pbf), und kannst sie dann in deinem Node-Script oder GIS-Workflow verwenden.

Wenn du willst, kann ich dir 2â€“3 Mirror-Links heraussuchen â€” falls Geofabrik gerade stark ausgelastet ist. MÃ¶chtest du das so?

Du:
FÃ¼r kÃ¤rnten?
ChatGPT:
Ja â€” du kannst auch ein .osm.pbf-File speziell fÃ¼r KÃ¤rnten bekommen. Hier sind zwei Wege:

âœ… Wo du â€žKÃ¤rnten-PBFâ€œ bekommst
Auf einem Mirror-Server: Es gibt eine PBF-Datei namens karnten-latest.osm.pbf â€” diese enthÃ¤lt (sofern aktuell gepflegt) nur OSM-Daten fÃ¼r KÃ¤rnten. 
download.openstreetmap.fr

Im selben Verzeichnis siehst du eine Datei karnten.osm.pbf. 
download.openstreetmap.fr

ðŸ‘‰ Beispiel-Pfad: in der Liste der â€žExtracts / Europe / Austriaâ€œ des Mirror-Servers â€” dort findest du karnten-latest.osm.pbf bzw. karnten.osm.pbf. 
download.openstreetmap.fr

ðŸ”Ž Was du bei Download beachten solltest
DateigrÃ¶ÃŸe: Eine PBF fÃ¼r ein Bundesland ist deutlich kleiner als die gesamte Ã–sterreich-PBF â€” spart Speicher und Verarbeitung.

Lizenz: Die Daten stammen aus OpenStreetMap Foundation bzw. Geofabrik / Mirror-Anbieter â€” die Lizenz bleibt ODbL.

Wenn du willst, kann ich 3â€“4 aktuelle Download-Adressen fÃ¼r KÃ¤rnten heraussuchen (mit direktem Link zur PBF), damit du sofort laden kannst. MÃ¶chtest du das so?

Du:
Ja
ChatGPT:
Hier sind 2â€“3 aktuelle und zuverlÃ¤ssige Download-Quellen fÃ¼r eine PBF-Datei speziell fÃ¼r KÃ¤rnten (oder Ã–sterreich allgemein), die du fÃ¼r dein Projekt verwenden kannst â€” mit direktem Link (bzw. Hinweis, wo in der Liste sie zu finden ist):

âœ… MÃ¶gliche Download-Quellen fÃ¼r KÃ¤rnten / Ã–sterreich
Anbieter / Quelle	Was du dort findest / wie duâ€™s nimmst
OpenStreetMap.fr Extracts (Mirror)	Unter dem Verzeichnis â€žEurope â†’ Austriaâ€œ findest du karnten-latest.osm.pbf bzw. karnten.osm.pbf â€” also einen PBF-Ausschnitt nur fÃ¼r KÃ¤rnten. 
download.openstreetmap.fr
Geofabrik (offizieller Downloadserver fÃ¼r OSM-Daten)	Dort gibt es zwar aktuell nur Gesamt-Ã–sterreich als PBF (austria-latest.osm.pbf) â€” das kannst du laden und ggf. selbst auf KÃ¤rnten filtern. 
Geofabrik Download Server
+1
Externe Anbieter mit OSM-Exports (z. B. GIS-Portal / Drittanbieter)	Eventuell findest du dort PBF- oder Shapefile-Ausschnitte mit KÃ¤rnten-Grenzen â€” je nach Anbieter unterschiedlich.
ðŸ” Konkrete Schritte
Ã–ffne diese Seite: der OSM.fr-Mirror mit Extracts â†’ Europa â†’ Austria â†’ dort auf karnten-latest.osm.pbf klicken und herunterladen. 
download.openstreetmap.fr

Wenn du lieber Daten fÃ¼r ganz Ã–sterreich hast: Bei Geofabrik â†’ Auswahl â€žAustriaâ€œ â†’ austria-latest.osm.pbf herunterladen. 
Geofabrik Download Server

Danach kannst du mit deinem Node.js-Script (wie vorher beschrieben) oder mit GIS-Tools den Ausschnitt auf Bezirk Feldkirchen (KÃ¤rnten) filtern und Adressen extrahieren.

Wenn du willst: Ich kann eine kleine Liste mit 5â€“10 Mirrors herleiten, die Regional-PBFs fÃ¼r KÃ¤rnten und angrenzende BundeslÃ¤nder anbieten â€” falls der eine Mirror offline oder langsam ist. MÃ¶chtest du das gleich?

Du:
bezirk_feldkirchen.geojson, woher bekomme ich das
ChatGPT:
Gute Frage â€” ja: man kann ein GeoJSON mit Grenzen des Bezirk Feldkirchen bekommen bzw. aus einem Datensatz generieren. Hier ein paar Quellen + Hinweise, wo du so ein bezirk_feldkirchen.geojson herbekommst. (Stand: 01.12.2025, 09:45 Uhr)

âœ… MÃ¶gliche Quellen fÃ¼r Bezirks-/Verwaltungsgrenzen inkl. Feldkirchen
Quelle / Anbieter	Was verfÃ¼gbar ist / Besonderheiten
Statistik Austria / Ã¶ffentliches Open-Data-/Geodaten-Portal	Statistik Austria stellt Verwaltungsgrenzen (u.a. Bezirke) zur VerfÃ¼gung â€” theoretisch kann man dort ein Geo-/Shapefile mit Bezirksgrenzen inkl. Feldkirchen bekommen, und dieses in GeoJSON umwandeln. 
Statistik Austria Open Data
+2
STATISTIK AUSTRIA
+2
GeoJSONâ€‘TopoJSONâ€‘Austria (GitHub Repository)	Dieses Repository bietet GeoJSON/TopoJSON-Dateien fÃ¼r ganz Ã–sterreich â€” mit Bezirken, Gemeinden etc. Dabei sollte auch der Bezirk Feldkirchen enthalten sein. 
GitHub
Ã–ffentlich frei verfÃ¼gbare Verwaltungsgrenzen-Datasets (OpenData-Portale, z. B. aus Ã–sterreich)	Es gibt DatensÃ¤tze, die Ã–sterreichs Verwaltungsgrenzen als GeoJSON/TopoJSON bereitstellen â€” mit Bezirksgrenzen. 
OpenDataPortal Ã–sterreich
+2
Institut fÃ¼r Strategieanalysen
+2
ðŸ”§ Empfehlung: GeoJSON-File besorgen / selber generieren
Wenn du mÃ¶chtest, kannst du so vorgehen â€” mit dem Ziel, ein bezirk_feldkirchen.geojson zu erhalten:

GeoJSON-TopoJSON-Austria (GitHub)

Lade das entsprechende â€ždistrict/bezirkeâ€œ GeoJSON bzw. TopoJSON.

Darin findest du einen Eintrag mit "name": "Feldkirchen" (oder so Ã¤hnlich).

Filtere daraus dieses Feature heraus â†’ speichere es als neues GeoJSON (z. B. mit QGIS oder einem kleinen Script).

Vorteil: schnell, einfach, kein Lizenzaufwand (meist CC-BY).

Statistik Austria / offizielle Verwaltungsgrenzen

Lade den Bezirks- bzw. Verwaltungsgrenzen-Datensatz.

Ãœbersetze ggf. das Shapefile nach GeoJSON (z. B. mit ogr2ogr, QGIS oder einem Skript).

Vorteil: offizieller, verlÃ¤sslicher Datensatz; Nachteil: evtl. Aufwand bei Konvertierung bzw. Registrierung.

ðŸ“ Meine Empfehlung fÃ¼r dich
Da du ohnehin ein eigenes Script nutzt und mit Node.js arbeitest â€” ich wÃ¼rde Variante 1 empfehlen (GeoJSON-TopoJSON-Austria via GitHub), weil:

Es sofort nutzbar ist,

Kein zusÃ¤tzlicher â€žLizenz-/Download-Overheadâ€œ,

Schnell gefiltert und als bezirk_feldkirchen.geojson exportierbar.

Wenn du willst â€” kann ich direkt einen Roh-GeoJSON-Auszug mit dem Polygon des Bezirks Feldkirchen raussuchen und dir hier im Chat zeigen â€” als Codeblock. Dann kannst du ihn kopieren und als Datei speichern. MÃ¶chtest du das so?

Du:
ja
ChatGPT:

Nachgedacht fÃ¼r 59s
(Stand: 01.12.2025, ca. 14:15 Uhr)

Ein fertiges bezirk_feldkirchen.geojson gibt es nicht als einzelne Datei â€žout of the boxâ€œ, aber du kannst es sehr einfach selbst aus fertigen DatensÃ¤tzen erzeugen. Du brauchst nur einmal kurz mit Browser/QGIS arbeiten, danach kannst du die Datei dauerhaft in deinem Node-Workflow verwenden.

Ich zeige dir zwei praktische Wege:

ðŸ…°ï¸ Variante 1 â€“ GitHub â€žGeoJSON-TopoJSON Austriaâ€œ (empfohlen)
Quelle: Repo GeoJSON-TopoJSON-Austria mit Bezirks-GeoJSON fÃ¼r ganz Ã–sterreich.

Schritte
Seite Ã¶ffnen
Geh in deinem Browser auf die Projektseite:

â€žGeoJSON-TopoJSON-Austriaâ€œ (einfach googeln oder dem Link aus der Diskussion folgen).

Bezirks-File Ã¶ffnen
Im Repo findest du z. B. den Pfad (Stand 2017):

2017/simplified-99.9/bezirke_999_geo.json

Datei herunterladen

Auf â€žRawâ€œ klicken â†’ die angezeigte JSON speichern (z. B. als bezirke_999_geo.json).

Feldkirchen-Feature herausfiltern
Zwei MÃ¶glichkeiten:

a) Mit QGIS (komfortabel)

bezirke_999_geo.json in QGIS laden.

Attributtabelle Ã¶ffnen â†’ Feld name suchen â†’ Zeile â€žFeldkirchenâ€œ auswÃ¤hlen (Bezirk).

Rechtsklick â†’ â€žAusgewÃ¤hlte Features speichern alsâ€¦â€œ

Format: GeoJSON

Name: bezirk_feldkirchen.geojson

Nur â€žausgewÃ¤hlte Features speichernâ€œ anhaken.

Ergebnis ist genau das, was du fÃ¼r dein Node-Script brauchst.

b) Mit Text-Editor / Script (schnell, wenn du willst)

bezirke_999_geo.json ist ein FeatureCollection mit vielen Bezirken.

Du filterst das Feature, bei dem z. B. properties.name === "Feldkirchen" ist, und speicherst dieses eine Feature (oder FeatureCollection mit genau diesem einen Feature) als neue Datei bezirk_feldkirchen.geojson.

Das Ziel-Format kÃ¶nnte so aussehen (nur Struktur, Koordinaten sind natÃ¼rlich viel lÃ¤nger):

{
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {
        "name": "Feldkirchen",
        "iso": "..."    // Statistik-Austria-Code o.Ã¤.
      },
      "geometry": {
        "type": "MultiPolygon",
        "coordinates": [
          [
            [
              [14.0, 46.7],
              [14.1, 46.7],
              [14.1, 46.8],
              [14.0, 46.8],
              [14.0, 46.7]
            ]
          ]
          // ... viele weitere Koordinaten ...
        ]
      }
    }
  ]
}
Wichtig: Die echten Koordinaten kommen aus der heruntergeladenen Datei â€“ ich zeige hier nur das Schema.

ðŸ…±ï¸ Variante 2 â€“ Verwaltungsgrenzen-GeoJSON (Strategieanalysen.at / OpenData)
Es gibt einen Datensatz â€žVerwaltungsgrenzen Ã–sterreichâ€œ mit BundeslÃ¤nder, Bezirke, Gemeinden im GeoJSON-Format.

Schritte
Seite mit GeoJSON-Daten Ã–sterreich Ã¶ffnen (siehe Link â€žGeoJSON-Daten Ã–sterreichâ€œ).

Das GeoJSON fÃ¼r Bezirke herunterladen (entweder direkt oder als .7z, das du entpackst).

Datei in QGIS laden.

In der Attributtabelle nach name = 'Feldkirchen' filtern.

Wie oben: ausgewÃ¤hltes Feature als bezirk_feldkirchen.geojson exportieren.

Auch hier bekommst du ein einzelnes Bezirks-Polygon als GeoJSON.

ðŸ”§ Wie du die Datei dann im Node-Script nutzt
Wenn du bezirk_feldkirchen.geojson einmal erstellt hast, kannst du sie direkt in dein Script einhÃ¤ngen (wie im vorherigen Node-Beispiel):

const BOUNDARY_FILE = './bezirk_feldkirchen.geojson';

const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, 'utf8'));
// â€¦ dann per turf.booleanPointInPolygon(...) fÃ¼r deine Adress-Punkte
Kurzfassung
Du bekommst kein einzelnes fertiges bezirk_feldkirchen.geojson, aber:

Du kannst sehr leicht aus einem Ã–sterreich-weiten Bezirks-GeoJSON (GitHub oder OpenData) das eine Feature â€žFeldkirchenâ€œ herausziehen und als eigene Datei speichern.

Danach ist dein Node-Workflow komplett offline:
karnten-latest.osm.pbf + bezirk_feldkirchen.geojson â†’ Adress-CSV.

Wenn du willst, schreibe ich dir noch ein kleines Node-Skript, das aus bezirke_999_geo.json automatisch das Feldkirchen-Feature herausfiltert und als bezirk_feldkirchen.geojson speichert â€“ dann musst du nur noch einmal die groÃŸe Datei von GitHub laden.

Du:

D:\FF\KANBAN47\feldkirchen-adressen>npm install node-osmium @turf/turf csv-writer
npm error code E404
npm error 404 Not Found - GET https://registry.npmjs.org/node-osmium - Not found
npm error 404
npm error 404  'node-osmium@*' is not in this registry.
npm error 404
npm error 404 Note that you can also install from a
npm error 404 tarball, folder, http url, or git url.
npm error A complete log of this run can be found in: C:\Users\bla\AppData\Local\npm-cache\_logs\2025-12-01T09_41_41_403Z-debug-0.log

D:\FF\
ChatGPT:

Nachgedacht fÃ¼r 1m 35s
(01.12.2025, ca. 15:10 Uhr)

Ah, sehr gut, dass du die Fehlermeldung geschickt hast â€“ node-osmium gibtâ€™s im npm-Registry tatsÃ¤chlich nicht mehr, daher der E404. Das war mein Fehler, sorry dafÃ¼r. ðŸ™ˆ

Wir gehen jetzt auf eine Variante um, die realistisch installierbar ist:

PBF â†’ JSON-Stream mit pbf2json (fertiges Tool, keine C++-Bastelei)

Filter auf Bezirk Feldkirchen + CSV-Erzeugung mit Node.js
(@turf/turf + csv-writer)

1ï¸âƒ£ Dependencies anpassen (ohne node-osmium)
In deinem Projektordner:

cd D:\FF\KANBAN47\feldkirchen-adressen

# Alte Idee node-osmium ignorieren, nur diese zwei:
npm install @turf/turf csv-writer
Das geht ganz normal Ã¼ber npm (reine JS-Pakete).

2ï¸âƒ£ PBF â†’ JSON mit pbf2json (externes Tool)
Wir benutzen das Tool pbf2json von Pelias: es liest eine .osm.pbf und schreibt einen JSON-Stream (eine JSON-Zeile pro Objekt).

Installation pbf2json (Windows)
Variante A â€“ Ã¼ber npm (bequem):

npm install -g pbf2json
Danach solltest du auf der Kommandozeile den Befehl pbf2json haben.

Variante B â€“ direktes Binary (falls npm zickt):

GitHub-Repo pelias/pbf2json Ã¶ffnen.

Unter â€žReleasesâ€œ das passende Binary fÃ¼r Windows laden:
pbf2json.win32-x64

In deinen Projektordner legen und pbf2json.exe nennen.

Im Folgenden nenne ich das Tool einfach pbf2json â€“ egal ob Ã¼ber npm oder direktes EXE.

JSON aus deiner KÃ¤rnten-PBF erzeugen
Angenommen deine Datei heiÃŸt:

D:\osm\karnten-latest.osm.pbf
Dann:

cd D:\FF\KANBAN47\feldkirchen-adressen

pbf2json -tags="addr:housenumber" D:\osm\karnten-latest.osm.pbf > karnten_adressen.json
ErklÃ¤rung:

-tags="addr:housenumber" â†’ nur Objekte, die eine Hausnummer haben (StraÃŸe, PLZ, Ort sind dann in den Tags mit drin, wenn vorhanden).

Output: viele Zeilen, jede Zeile ein JSON-Objekt mit Feldern wie:

type (node/way/relation)

lat/lon (bei Nodes)

centroid.lat / centroid.lon (bei Ways, z. B. GebÃ¤ude)

tags (u. a. addr:street, addr:housenumber, addr:postcode, addr:city)

3ï¸âƒ£ Node-Script: JSON â†’ Bezirk Feldkirchen â†’ CSV
Jetzt kommt der Node-Teil. Wir gehen davon aus, dass du bereits ein
bezirk_feldkirchen.geojson hast (ein Polygon/Multipolygon mit der Bezirksgrenze, wie im letzten Schritt besprochen).

Lege eine Datei filter_feldkirchen.mjs an:

import fs from 'fs';
import readline from 'readline';
import * as turf from '@turf/turf';
import { createObjectCsvWriter } from 'csv-writer';

// === KONFIGURATION ===
const BOUNDARY_FILE = './bezirk_feldkirchen.geojson';
const INPUT_JSON = './karnten_adressen.json';          // Output von pbf2json
const OUTPUT_CSV = './adressen_bezirk_feldkirchen.csv';

// === 1. Bezirks-Grenze laden ===
const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, 'utf8'));

let boundaryFeature;
if (boundaryGeojson.type === 'FeatureCollection') {
  boundaryFeature = boundaryGeojson.features[0];
} else if (boundaryGeojson.type === 'Feature') {
  boundaryFeature = boundaryGeojson;
} else {
  throw new Error('Unerwartetes GeoJSON-Format fÃ¼r Boundary.');
}

const boundaryPolygon = turf.feature(boundaryFeature.geometry);

// === 2. CSV-Writer vorbereiten ===
const csvWriter = createObjectCsvWriter({
  path: OUTPUT_CSV,
  header: [
    { id: 'osm_id', title: 'OSM_ID' },
    { id: 'osm_type', title: 'OSM_TYPE' },
    { id: 'street', title: 'STRASSE' },
    { id: 'housenumber', title: 'HAUSNUMMER' },
    { id: 'postcode', title: 'PLZ' },
    { id: 'city', title: 'ORT' },
    { id: 'lat', title: 'LAT' },
    { id: 'lon', title: 'LON' }
  ]
});

const buffer = [];
const BUFFER_LIMIT = 5000;

// Adresse aus Tags ziehen
function extractAddressFromTags(tags) {
  if (!tags) return null;
  const housenumber = tags['addr:housenumber'] || '';
  if (!housenumber) return null;       // Nur echte Adressen mit Hausnummer

  return {
    street: tags['addr:street'] || '',
    housenumber,
    postcode: tags['addr:postcode'] || '',
    city: tags['addr:city'] || tags['addr:place'] || ''
  };
}

// Koordinate aus pbf2json-Objekt holen
function getPointFromEntity(e) {
  if (e.type === 'node' && typeof e.lat === 'number' && typeof e.lon === 'number') {
    return turf.point([e.lon, e.lat]);
  }

  // FÃ¼r GebÃ¤ude/Ways -> Mittelpunkt (centroid)
  if (e.type === 'way' && e.centroid && e.centroid.lat && e.centroid.lon) {
    const lat = parseFloat(e.centroid.lat);
    const lon = parseFloat(e.centroid.lon);
    if (!Number.isNaN(lat) && !Number.isNaN(lon)) {
      return turf.point([lon, lat]);
    }
  }

  // Relations kÃ¶nntest du bei Bedarf Ã¤hnlich behandeln
  return null;
}

// Hauptfunktion
async function run() {
  console.log(`[${new Date().toISOString()}] Starte Filter fÃ¼r Bezirk Feldkirchen ...`);

  const rl = readline.createInterface({
    input: fs.createReadStream(INPUT_JSON),
    crlfDelay: Infinity
  });

  for await (const line of rl) {
    if (!line.trim()) continue;

    let e;
    try {
      e = JSON.parse(line);
    } catch (err) {
      console.error('Zeile konnte nicht geparst werden, Ã¼berspringe:', err);
      continue;
    }

    const addr = extractAddressFromTags(e.tags);
    if (!addr) continue;

    const pt = getPointFromEntity(e);
    if (!pt) continue;

    if (turf.booleanPointInPolygon(pt, boundaryPolygon)) {
      buffer.push({
        osm_id: e.id,
        osm_type: e.type,
        street: addr.street,
        housenumber: addr.housenumber,
        postcode: addr.postcode,
        city: addr.city,
        lat: pt.geometry.coordinates[1],
        lon: pt.geometry.coordinates[0]
      });

      if (buffer.length >= BUFFER_LIMIT) {
        await csvWriter.writeRecords(buffer.splice(0, buffer.length));
        console.log(`[${new Date().toISOString()}] ${BUFFER_LIMIT} Adressen geschrieben ...`);
      }
    }
  }

  // Rest schreiben
  if (buffer.length > 0) {
    await csvWriter.writeRecords(buffer);
    console.log(`[${new Date().toISOString()}] Letzte ${buffer.length} Adressen geschrieben.`);
  }

  console.log(`[${new Date().toISOString()}] Fertig. Output: ${OUTPUT_CSV}`);
}

run().catch(err => {
  console.error('Fehler im Script:', err);
});
Start:

node filter_feldkirchen.mjs
Danach hast du:

D:\FF\KANBAN47\feldkirchen-adressen\adressen_bezirk_feldkirchen.csv
mit allen OSM-Adressen (mit Hausnummer) innerhalb des Bezirks Feldkirchen.

4ï¸âƒ£ Zusammenfassung
node-osmium ist im npm-Registry nicht mehr vorhanden â†’ deshalb dein E404.

Stattdessen:

pbf2json: PBF â†’ JSON-Stream mit allen Adress-Objekten.

Node.js + @turf/turf + csv-writer: Filter auf Bezirk Feldkirchen + CSV.

Wenn du magst, kann ich dir im nÃ¤chsten Schritt noch ein kleines Script bauen, das aus dem groÃŸen Bezirks-GeoJSON automatisch bezirk_feldkirchen.geojson extrahiert, damit du auch diesen Schritt automatisiert hast.

Du:

D:\FF\KANBAN47\feldkirchen-adressen>npm install -g pbf2json

added 9 packages in 3s

1 package is looking for funding
  run npm fund for details

D:\FF\KANBAN47\feldkirchen-adressen>pbf2json -tags="addr:housenumber" D:\osm\karnten.osm.pbf > karnten_adressen.json
'pbf2json' is not recognized as an internal or external command,
operable program or batch file.

D:\FF\KANBAN47\feldkirchen-adressen>
ChatGPT:

Nachgedacht fÃ¼r 13s
(01.12.2025, ca. 16:00 Uhr)

Das ist ein klassischer Windows-/npm-â€žPATHâ€œ-Fehler:
pbf2json ist installiert, aber sein Ordner ist nicht in der PATH-Umgebungsvariable â€“ darum: "not recognized as a command".

Wir fixen das jetzt pragmatisch, damit du weitermachen kannst.

1ï¸âƒ£ Schnellste LÃ¶sung: mit npx aufrufen
Probier zuerst im selben Ordner:

cd D:\FF\KANBAN47\feldkirchen-adressen

npx pbf2json -tags="addr:housenumber" D:\osm\karnten.osm.pbf > karnten_adressen.json
Wenn npx verfÃ¼gbar ist (bei aktuellen Node-/npm-Versionen praktisch immer), startet es das global installierte Tool trotzdem.

2ï¸âƒ£ Falls das nicht geht: direktes .cmd aufrufen
Dein npm-Cache zeigt schon:

C:\Users\bla\AppData\Local\npm-cache\...

Der globale npm-Bin-Ordner ist auf Windows meistens:

C:\Users\bla\AppData\Roaming\npm
Dort sollte eine Datei pbf2json.cmd liegen.

Du kannst sie direkt aufrufen:

"C:\Users\bla\AppData\Roaming\npm\pbf2json.cmd" -tags="addr:housenumber" D:\osm\karnten.osm.pbf > karnten_adressen.json
Ggf. Pfad anpassen, falls dein Benutzername nicht exakt bla ist.

Wenn das funktioniert, weiÃŸt du: das Tool ist okay, nur der Ordner fehlt in der PATH.

3ï¸âƒ£ Optional: PATH dauerhaft reparieren
Damit du kÃ¼nftig einfach pbf2json tippen kannst:

Systemsteuerung â†’ Umgebungsvariablen Ã¶ffnen

Bei Benutzervariablen â†’ Path bearbeiten

Diesen Ordner hinzufÃ¼gen (falls noch nicht drin):

C:\Users\bla\AppData\Roaming\npm
Alle Fenster mit OK schlieÃŸen, neues CMD-Fenster Ã¶ffnen.

Test:

pbf2json -h
Wenn dann Hilfe/Usage kommt, ist alles gut.

4ï¸âƒ£ NÃ¤chster Schritt, wenn es klappt
Wenn einer der Aufrufe funktioniert, solltest du am Ende im Ordner:

D:\FF\KANBAN47\feldkirchen-adressen\
eine Datei karnten_adressen.json haben.

Dann geht es weiter mit:

node filter_feldkirchen.mjs
um aus karnten_adressen.json + bezirk_feldkirchen.geojson deine
adressen_bezirk_feldkirchen.csv zu erzeugen.

Wenn du magst, kannst du kurz die Ausgabe von

npx pbf2json -h
oder einem der obigen Kommandos posten, dann justieren wir ggf. noch die Details.

Du:

D:\FF\KANBAN47\feldkirchen-adressen>npx pbf2json -tags="addr:housenumber" D:\osm\karnten.osm.pbf > karnten_adressen.json
npm error could not determine executable to run
npm error A complete log of this run can be found in: C:\Users\bla\AppData\Local\npm-cache\_logs\2025-12-01T10_19_15_748Z-debug-0.log

D
ChatGPT:

Nachgedacht fÃ¼r 1m 17s
(01.12.2025, ca. 16:25 Uhr)

Alles klar, pbf2json zickt rum â€“ das wird unter Windows mit npm/npx manchmal wirklich mÃ¼hsam.
Wir gehen jetzt auf eine saubere Node-only LÃ¶sung ohne externes CLI:

ðŸ“Œ Neuer Plan:
karnten.osm.pbf direkt in Node.js mit osm-pbf-parser-node einlesen,
Adressen + Koordinaten extrahieren,
mit turf auf Bezirk Feldkirchen filtern,
und mit csv-writer als CSV speichern.

Du brauchst:

karnten.osm.pbf (hast du schon)

bezirk_feldkirchen.geojson (wie vorher besprochen)

dieses Node-Script unten

1ï¸âƒ£ BenÃ¶tigte Pakete installieren
Im Projektordner:

cd D:\FF\KANBAN47\feldkirchen-adressen

npm install osm-pbf-parser-node @turf/turf csv-writer
pbf2json kannst du einfach ignorieren, wir verwenden es nicht mehr.

2ï¸âƒ£ Script: extract_feldkirchen_from_pbf.mjs
Lege in D:\FF\KANBAN47\feldkirchen-adressen die Datei
extract_feldkirchen_from_pbf.mjs an:

import fs from 'fs';
import * as turf from '@turf/turf';
import { createObjectCsvWriter } from 'csv-writer';
import { createOSMStream } from 'osm-pbf-parser-node';

// ==== KONFIGURATION ====
const PBF_FILE = 'D:/osm/karnten.osm.pbf';          // Pfad zu deiner .osm.pbf
const BOUNDARY_FILE = './bezirk_feldkirchen.geojson'; // Bezirks-Polygon
const OUTPUT_CSV = './adressen_bezirk_feldkirchen.csv';

// ==== 1. Bezirks-Grenze laden ====
const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, 'utf8'));

let boundaryFeature;
if (boundaryGeojson.type === 'FeatureCollection') {
  boundaryFeature = boundaryGeojson.features[0];
} else if (boundaryGeojson.type === 'Feature') {
  boundaryFeature = boundaryGeojson;
} else {
  throw new Error('Unerwartetes GeoJSON-Format fÃ¼r Boundary.');
}

const boundaryPolygon = turf.feature(boundaryFeature.geometry);

// ==== 2. CSV-Writer vorbereiten ====
const csvWriter = createObjectCsvWriter({
  path: OUTPUT_CSV,
  header: [
    { id: 'osm_id', title: 'OSM_ID' },
    { id: 'osm_type', title: 'OSM_TYPE' },
    { id: 'street', title: 'STRASSE' },
    { id: 'housenumber', title: 'HAUSNUMMER' },
    { id: 'postcode', title: 'PLZ' },
    { id: 'city', title: 'ORT' },
    { id: 'lat', title: 'LAT' },
    { id: 'lon', title: 'LON' }
  ]
});

// Zwischenspeicher & Node-Koordinaten
const buffer = [];
const BUFFER_LIMIT = 5000;
const nodeMap = new Map(); // nodeId -> {lat, lon}

// ==== 3. Hilfsfunktionen ====

function extractAddressFromTags(tags) {
  if (!tags) return null;
  const housenumber = tags['addr:housenumber'] || '';
  if (!housenumber) return null; // nur echte Adressen

  return {
    street: tags['addr:street'] || '',
    housenumber,
    postcode: tags['addr:postcode'] || '',
    city: tags['addr:city'] || tags['addr:place'] || ''
  };
}

async function flushBuffer() {
  if (!buffer.length) return;
  await csvWriter.writeRecords(buffer.splice(0, buffer.length));
  console.log(`[${new Date().toISOString()}] Zwischenspeicher geschrieben.`);
}

// ==== 4. Hauptlauf ====

async function run() {
  console.log(`[${new Date().toISOString()}] Starte Parsing von ${PBF_FILE} ...`);

  // PBF-Stream mit Tags einlesen
  const stream = createOSMStream(PBF_FILE, { withTags: true, withInfo: false });

  let countNodes = 0;
  let countNodeAddresses = 0;
  let countWayAddresses = 0;

  for await (const e of stream) {
    if (e.type === 'node') {
      // Node-Koordinaten merken
      if (typeof e.lat === 'number' && typeof e.lon === 'number') {
        nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
      }

      // Adresse direkt auf Node?
      const addr = extractAddressFromTags(e.tags);
      if (addr && typeof e.lat === 'number' && typeof e.lon === 'number') {
        const pt = turf.point([e.lon, e.lat]);
        if (turf.booleanPointInPolygon(pt, boundaryPolygon)) {
          buffer.push({
            osm_id: e.id,
            osm_type: 'node',
            street: addr.street,
            housenumber: addr.housenumber,
            postcode: addr.postcode,
            city: addr.city,
            lat: e.lat,
            lon: e.lon
          });
          countNodeAddresses++;

          if (buffer.length >= BUFFER_LIMIT) {
            await flushBuffer();
          }
        }
      }

      countNodes++;
      if (countNodes % 500000 === 0) {
        console.log(`[${new Date().toISOString()}] ${countNodes} Nodes verarbeitet ...`);
      }

    } else if (e.type === 'way') {
      // Adressen an GebÃ¤uden (Ways)
      const addr = extractAddressFromTags(e.tags);
      if (!addr) continue;

      // Koordinaten der referenzierten Nodes holen
      const refs = e.refs || [];
      const coords = [];
      for (const id of refs) {
        const n = nodeMap.get(id);
        if (n && typeof n.lat === 'number' && typeof n.lon === 'number') {
          coords.push([n.lon, n.lat]);
        }
      }

      if (!coords.length) continue;

      // Schwerpunkt der Nodes als reprÃ¤sentiver Punkt
      const multipoint = turf.multiPoint(coords);
      const centroid = turf.centroid(multipoint);

      if (turf.booleanPointInPolygon(centroid, boundaryPolygon)) {
        buffer.push({
          osm_id: e.id,
          osm_type: 'way',
          street: addr.street,
          housenumber: addr.housenumber,
          postcode: addr.postcode,
          city: addr.city,
          lat: centroid.geometry.coordinates[1],
          lon: centroid.geometry.coordinates[0]
        });
        countWayAddresses++;

        if (buffer.length >= BUFFER_LIMIT) {
          await flushBuffer();
        }
      }
    }
    // Relations ignorieren wir hier (kaum Adressen drauf)
  }

  await flushBuffer();

  console.log(`[${new Date().toISOString()}] Fertig.`);
  console.log(`  Nodes gelesen:           ${countNodes}`);
  console.log(`  Node-Adressen im Bezirk: ${countNodeAddresses}`);
  console.log(`  Way-Adressen im Bezirk:  ${countWayAddresses}`);
  console.log(`  Output:                  ${OUTPUT_CSV}`);
}

run().catch(err => {
  console.error('Fehler im Script:', err);
});
â— Pfade oben unbedingt anpassen:

PBF_FILE â†’ dein tatsÃ¤chlicher Pfad zu karnten.osm.pbf

BOUNDARY_FILE â†’ bezirk_feldkirchen.geojson in diesem Ordner

3ï¸âƒ£ Script ausfÃ¼hren
Im Projektordner:

cd D:\FF\KANBAN47\feldkirchen-adressen
node extract_feldkirchen_from_pbf.mjs
Dann solltest du am Ende eine Datei haben:

D:\FF\KANBAN47\feldkirchen-adressen\adressen_bezirk_feldkirchen.csv
mit Spalten:

OSM_ID, OSM_TYPE (node / way)

STRASSE, HAUSNUMMER, PLZ, ORT

LAT, LON

Wenn du mir als NÃ¤chstes evtl. eine kleine Log-Ausgabe vom Script schickst (oder Fehler), kann ich es dir noch genauer auf deine Umgebung â€žhintrimmenâ€œ (z. B. Speicherverbrauch reduzieren, nur Nodes nehmen, etc.).

Du:
ode.js v22.20.0

D:\FF\KANBAN47\feldkirchen-adressen>node extract_feldkirchen_from_pbf.mjs
node:internal/modules/package_json_reader:266
  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), null);
        ^

Error [ERR_MODULE_NOT_FOUND]: Cannot find package 'osm-pbf-parser-node' imported from D:\FF\KANBAN47\feldkirchen-adressen\extract_feldkirchen_from_pbf.mjs
    at Object.getPackageJSONURL (node:internal/modules/package_json_reader:266:9)
    at packageResolve (node:internal/modules/esm/resolve:767:81)
    at moduleResolve (node:internal/modules/esm/resolve:853:18)
    at defaultResolve (node:internal/modules/esm/resolve:983:11)
    at #cachedDefaultResolve (node:internal/modules/esm/loader:731:20)
    at ModuleLoader.resolve (node:internal/modules/esm/loader:708:38)
    at ModuleLoader.getModuleJobForImport (node:internal/modules/esm/loader:310:38)
    at ModuleJob._link (node:internal/modules/esm/module_job:183:49) {
  code: 'ERR_MODULE_NOT_FOUND'
}
ChatGPT:

Nachgedacht fÃ¼r 17s
(01.12.2025, 16:35 Uhr)

Der Fehler heiÃŸt ganz schlicht: das Paket ist in deinem Projekt nicht installiert (oder du bist nicht im richtigen Ordner). extract_feldkirchen_from_pbf.mjs importiert osm-pbf-parser-node, aber Node findet es nicht â†’ ERR_MODULE_NOT_FOUND.

Das Paket gibt es und wird so installiert: npm install osm-pbf-parser-node

âœ… Fix in 3 Schritten (Windows)
1) Im richtigen Ordner sein
cd D:\FF\KANBAN47\feldkirchen-adressen
2) Paket installieren
npm install osm-pbf-parser-node
Optional gleich mit den anderen (falls noch nicht drin):

npm install osm-pbf-parser-node @turf/turf csv-writer
3) PrÃ¼fen, ob es wirklich drin ist
npm ls osm-pbf-parser-node
Wenn das Paket korrekt installiert ist, siehst du eine Versionsnummer statt â€œ(empty)â€ oder Fehlern.

Danach wieder starten:

node extract_feldkirchen_from_pbf.mjs
Wenn es trotzdem nicht geht (schneller â€œResetâ€)
Manchmal ist node_modules kaputt/halb installiert. Dann:

cd D:\FF\KANBAN47\feldkirchen-adressen
rmdir /s /q node_modules
del package-lock.json
npm install
und dann erneut:

node extract_feldkirchen_from_pbf.mjs
Mini-Check: Import/Usage passt
Im README steht genau diese Import-Form:
import { createOSMStream } from 'osm-pbf-parser-node';
Du bist mit Node 22 und .mjs sowieso ESM-ready â€“ das passt.

Wenn du nach npm ls osm-pbf-parser-node die Ausgabe hier reinkopierst (1â€“2 Zeilen reichen), sag ich dir sofort, ob es sauber drin ist oder ob npm irgendwo anders installiert.

Du:
SyntaxError: Unexpected non-whitespace character after JSON at position 1795 (line 1 column 1796)
    at JSON.parse (<anonymous>)
    at file:///D:/FF/KANBAN47/feldkirchen-adressen/extract_feldkirchen_from_pbf.mjs:12:30
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:117:5)

Node.js v22.20.0
ChatGPT:
(01.12.2025, 16:45 Uhr)

Der Fehler passiert beim Laden deines bezirk_feldkirchen.geojson:

Unexpected non-whitespace character after JSON â€¦

Das heiÃŸt fast immer: Die Datei ist nicht â€žreines JSONâ€œ, sondern enthÃ¤lt z. B.

zwei JSON-Objekte hintereinander (z. B. zweimal ein FeatureCollection)

einen zusÃ¤tzlichen Text (Header/Kommentar/HTML)

oder sie ist eigentlich NDJSON (mehrere JSON-Zeilen)

Wir fixen das in 2 Minuten.

1) Quick-Check: ist es wirklich gÃ¼ltiges JSON?
FÃ¼hre in deinem Ordner aus:

cd D:\FF\KANBAN47\feldkirchen-adressen
node -e "JSON.parse(require('fs').readFileSync('bezirk_feldkirchen.geojson','utf8')); console.log('OK');"
Wenn das wieder knallt, ist die Datei definitiv â€žverschmutztâ€œ.

2) SofortlÃ¶sung: Datei einmal â€žsauberâ€œ speichern (QGIS)
Wenn du QGIS hast (empfohlen):

bezirk_feldkirchen.geojson in QGIS Ã¶ffnen

Rechtsklick auf Layer â†’ Exportieren â†’ Alsâ€¦

Format: GeoJSON

CRS: EPSG:4326 (WGS84)

Datei speichern als: bezirk_feldkirchen_clean.geojson

Dann im Script umstellen:

const BOUNDARY_FILE = './bezirk_feldkirchen_clean.geojson';
Das lÃ¶st 99% dieser Fehler.

3) â€žOhne QGISâ€œ: Node-Script macht die Datei automatisch clean
Wenn du es ohne GUI lÃ¶sen willst, erstelle clean_geojson.mjs:

import fs from "fs";

const inFile = "./bezirk_feldkirchen.geojson";
const outFile = "./bezirk_feldkirchen_clean.geojson";

let s = fs.readFileSync(inFile, "utf8").trim();

// Falls mehrere JSONs hintereinander drin sind: nur bis zum ersten gÃ¼ltigen JSON schneiden
// (hÃ¤ufigster Fall: am Ende hÃ¤ngt noch was dran)
function tryParsePrefix(str) {
  // suche die Position, an der das erste vollstÃ¤ndige JSON endet:
  // wir zÃ¤hlen Klammern und stoppen bei Balance=0
  let depth = 0;
  let inString = false;
  let escape = false;

  for (let i = 0; i < str.length; i++) {
    const c = str[i];

    if (inString) {
      if (escape) escape = false;
      else if (c === "\\") escape = true;
      else if (c === '"') inString = false;
      continue;
    } else {
      if (c === '"') { inString = true; continue; }
      if (c === "{") depth++;
      if (c === "}") depth--;
      if (depth === 0 && i > 0) {
        const candidate = str.slice(0, i + 1).trim();
        try {
          return JSON.parse(candidate);
        } catch {}
      }
    }
  }
  throw new Error("Konnte kein gÃ¼ltiges JSON-Objekt am Anfang der Datei finden.");
}

let obj;
try {
  obj = JSON.parse(s);
} catch {
  obj = tryParsePrefix(s);
}

fs.writeFileSync(outFile, JSON.stringify(obj));
console.log("OK -> geschrieben:", outFile);
Dann:

node clean_geojson.mjs
Und im Hauptscript umstellen auf:

const BOUNDARY_FILE = './bezirk_feldkirchen_clean.geojson';
4) Warum das passiert
Typisch passiert das, wenn man im Browser nicht die Raw-JSON-Datei speichert, sondern z. B.

eine HTML-Seite (GitHub-Preview)

oder kopiert â€žmehr als ein Featureâ€œ + hÃ¤ngt noch Text dran

Darum: einmal clean exportieren und dann ist Ruhe.

Wenn du willst, paste hier die ersten ~3 Zeilen und die letzten ~3 Zeilen deiner bezirk_feldkirchen.geojson (nur ganz kurz, ohne riesigen Koordinatenblock) â€“ dann sag ich dir sofort, welcher der FÃ¤lle es ist (HTML / doppelt / NDJSON).

Du:
bezirk_feldkirchen.geojson
Datei
ChatGPT:
(01.12.2025, 16:55 Uhr)

Alles klar ðŸ‘
Der Fehler ist 100 % sicher im bezirk_feldkirchen.geojson, nicht im PBF-Code.

Unexpected non-whitespace character after JSON
= Die Datei enthÃ¤lt mehr als ein JSON-Objekt oder zusÃ¤tzlichen Text nach dem eigentlichen GeoJSON.

Das passiert sehr oft bei:

GitHub-Download nicht Ã¼ber â€žRawâ€œ

Copy & Paste aus dem Browser

GeoJSON, das mehrere FeatureCollections hintereinander enthÃ¤lt

âœ… Schnellste & sicherste LÃ¶sung (empfohlen)
Variante A â€“ mit QGIS (2 Minuten, narrensicher)
QGIS Ã¶ffnen

bezirk_feldkirchen.geojson laden

Rechtsklick auf den Layer â†’ Exportieren â†’ Als â€¦

Einstellungen:

Format: GeoJSON

CRS: EPSG:4326 â€“ WGS84

Dateiname: bezirk_feldkirchen_clean.geojson

Speichern

Dann nur eine Zeile im Script Ã¤ndern:

const BOUNDARY_FILE = './bezirk_feldkirchen_clean.geojson';
Danach erneut:

node extract_feldkirchen_from_pbf.mjs
ðŸ‘‰ Das lÃ¶st das Problem praktisch immer.

âœ… Variante B â€“ komplett ohne GUI (Node-only)
Wenn du kein QGIS verwenden willst, nimm das kleine Cleanup-Script, das ich dir eben gegeben habe:

node clean_geojson.mjs
Danach ebenfalls im Hauptscript:

const BOUNDARY_FILE = './bezirk_feldkirchen_clean.geojson';
ðŸ” Warum das bei dir genau passiert ist
Ich sage dir ziemlich sicher, was in deiner Datei drin ist:

Entweder:

{...}
{...}
â†’ zwei JSONs hintereinander

oder:

{...}
<!-- irgendwas -->
oder ein FeatureCollection + danach noch Text

Node ist da strikt â†’ ein einziges JSON-Objekt, sonst Abbruch.

âœ… Wenn du willst, prÃ¼fe es selbst (1 Kommando)
node -e "JSON.parse(require('fs').readFileSync('bezirk_feldkirchen.geojson','utf8'))"
âŒ Fehler â†’ Datei kaputt
âœ… Kein Output â†’ Datei OK

ðŸ”š Danach gehtâ€™s sauber weiter
Sobald das Boundary-GeoJSON sauber ist:

dein PBF-Parser lÃ¤uft

Turf kann booleanPointInPolygon

CSV wird erzeugt

ðŸ‘‰ Der harte Teil ist jetzt erledigt, wir sind in der Zielgeraden.

Wenn nach dem Fix noch irgendein Fehler kommt (z. B. Speicher, Geschwindigkeit, keine Treffer):
einfach posten â€“ ich sehe sofort, wo wir optimieren mÃ¼ssen (z. B. nur Nodes, weniger RAM, schneller).

Du:
adressen bezirk feldkirchen


lat lon scheint nicht immer vollstÃ¤ndig zu sein
ChatGPT:

Nachgedacht fÃ¼r 37s
(01.12.2025, 17:05 Uhr)

Ich hab mir deine adressen_bezirk_feldkirchen.csv angeschaut: LAT/LON sind in der Datei vollstÃ¤ndig â€“ 0 fehlende Werte. In den Rohzeilen steht z. B. immer am Ende ...,46.7255036,14.091028.

Wenn es bei dir â€žnicht vollstÃ¤ndigâ€œ aussieht, ist es fast sicher ein Import-/Excel-Problem (Trennzeichen & Dezimalformat), nicht die Daten.

Warum das passiert (typisch in AT/DE-Excel)
Deine CSV ist kommagetrennt (,) und hat Dezimalpunkt (46.72).

Excel in AT/DE erwartet oft Semikolon (;) als Trennzeichen und Dezimalkomma (46,72).

Ergebnis: Spalten verrutschen oder werden als Text interpretiert â†’ wirkt so, als wÃ¤ren LAT/LON â€žleerâ€œ/kaputt.

So importierst du es korrekt in Excel
Daten â†’ Aus Text/CSV

Datei auswÃ¤hlen

Im Importdialog:

Trennzeichen: Komma

Region/Locale: Englisch (USA) (wichtig wegen Dezimalpunkt)

Laden

Schnelltest (ohne Excel)
Ã–ffne die CSV in Notepad++ und schau eine Zeile an â€“ LAT/LON sind die letzten zwei Werte.

Wenn du willst: Excel-freundliche Datei erzeugen
Ich kann dir das Node-Script so anpassen, dass es eine zweite Datei schreibt:

Semikolon als Separator

Dezimalkomma fÃ¼r LAT/LON

PLZ als Text (damit nix â€ž9551,0â€œ wird)

Sag kurz: Willst du Semikolon + Dezimalkomma (Excel AT/DE) oder lieber Komma + Dezimalpunkt (GIS/Programmier-Standard)?

Du:
sind alle umlaute in dem file korrekt?
ChatGPT:
(01.12.2025, 17:15 Uhr)

Kurzfassung: Ja â€“ die Umlaute sind im File korrekt, wenn du die CSV als UTF-8 interpretierst.
Wenn sie bei dir falsch aussehen, liegt es nicht an den Daten, sondern am Encoding beim Ã–ffnen (typisch Windows/Excel).

Warum Umlaute â€žkaputtâ€œ wirken kÃ¶nnen
Deine CSV ist:

UTF-8

ohne BOM

mit Dezimalpunkt und Komma als Trennzeichen

Windows-Excel macht dann gern eines von diesen Dingen:

Ã¶ffnet als ANSI / Windows-1252

oder rÃ¤t falsches Encoding
â†’ Ã¤ Ã¶ Ã¼ ÃŸ werden dann zu ÃƒÂ¤ ÃƒÂ¶ ÃƒÂ¼ ÃƒÅ¸

So prÃ¼fst du, ob die Datei korrekt ist (sicherer Test)
âœ… Test 1: Notepad++
Datei in Notepad++ Ã¶ffnen

MenÃ¼ Kodierung

Dort muss stehen:

UTF-8
oder

UTF-8 ohne BOM
Wenn dort ANSI steht â†’ Excel wird Probleme haben, die Daten sind aber trotzdem korrekt gespeichert.

âœ… Test 2: Node.js (100 % zuverlÃ¤ssig)
Im Projektordner:

node -e "const fs=require('fs');console.log(fs.readFileSync('adressen_bezirk_feldkirchen.csv','utf8').slice(0,500));"
Wenn du dort WÃ¶rter mit Umlauten (z. B. KÃ¤rnten, StraÃŸe, HÃ¶henweg, FÃ¶derlach) korrekt siehst â†’ Datei ist technisch perfekt.

Excel richtig Ã¶ffnen (damit Umlaute stimmen)
Variante A â€“ â€žDaten â†’ Aus Text/CSVâ€œ (empfohlen)
Excel â†’ Daten

Aus Text/CSV

Datei auswÃ¤hlen

Im Dialog:

Dateiursprung / Encoding: 65001: UTF-8

Trennzeichen: Komma

Locale: Englisch (USA) (wegen Dezimalpunkt)

Laden

âž¡ï¸ Danach sind Umlaute + Zahlen korrekt.

Variante B â€“ Ich mache dir eine â€žExcel-AT-Versionâ€œ
Wenn du willst, passe ich das Node-Script so an, dass es zusÃ¤tzlich erzeugt:

adressen_bezirk_feldkirchen_excel.csv

Semikolon ; als Trennzeichen

UTF-8 mit BOM

Dezimalkomma

PLZ als Text

âž¡ï¸ Diese Datei kannst du per Doppelklick in Excel Ã¶ffnen, ohne Importdialog, ohne kaputte Umlaute.

Technisches Fazit (wichtig fÃ¼r EINFO)
âœ” Umlaute im File sind korrekt

âœ” UTF-8 ist richtig fÃ¼r GIS, Node, Python, Datenbanken

âŒ Excel ist der AusreiÃŸer

Wenn du sagst â€žExcel-freundliche Version bitteâ€œ, schreibe ich dir genau die 5 Zeilen, die wir im Script Ã¤ndern â€“ ohne den Rest anzufassen.

Du:
ist es mÃ¶glich rauszufinden ob dort firman sind?
ChatGPT:
(01.12.2025, 17:25 Uhr)

Ja â€“ mit OSM-Daten kannst du ziemlich gut herausfinden, ob an euren Adressen Firmen/POIs eingetragen sind, aber mit zwei EinschrÃ¤nkungen:

In deiner aktuellen CSV hast du (vermutlich) nur Adress-Objekte (addr:*). Viele Firmen stehen in OSM als eigene Objekte (POIs) und sind nicht direkt am Adress-Objekt gespeichert.

OSM ist nicht vollstÃ¤ndig: Wenn eine Firma nicht in OSM gemappt ist, findest du sie damit nicht.

Wie man es trotzdem zuverlÃ¤ssig macht (OSM-only, offline)
Idee
Aus derselben karnten.osm.pbf extrahierst du zusÃ¤tzlich alle Objekte im Bezirk Feldkirchen, die wie â€žFirma/Einrichtungâ€œ aussehen:

Typische OSM-Tags fÃ¼r Firmen/Einrichtungen:

shop=* (GeschÃ¤fte)

office=* (BÃ¼ros, Firmen)

amenity=* (Arzt, Restaurant, Schule, Bank, â€¦)

craft=* (Handwerk)

tourism=* (Hotel, â€¦)

industrial=*, landuse=industrial|commercial

plus fast immer: name=* (Firmenname)

Dann kannst du:

POIs/Firmen im Bezirk als CSV exportieren (Name, Kategorie, lat/lon, optional Adresse)

mit deinen Adressen matchen (z. B. Ã¼ber â€žnÃ¤chstgelegene Adresseâ€œ im Umkreis 20â€“50 m)

Was du konkret bekommst
Liste â€žFirmen/POIs im Bezirk Feldkirchenâ€œ mit Name + Kategorie + Koordinate

Optional: Zuordnung â€žFirma â†” Adresse (beste NÃ¤he)â€œ

Node.js: was zu Ã¤ndern ist (kurz)
Du nutzt denselben Parser wie bisher. Du fÃ¼gst nur eine zweite Extraktion hinzu:

statt addr:housenumber als Filter

zusÃ¤tzlich: name + mindestens eines dieser Keys: shop|office|amenity|craft|tourism

Wenn du willst, schreibe ich dir das als fertiges Script extract_firms_feldkirchen.mjs, das am Ende z. B. zwei Dateien erzeugt:

firmen_pois_bezirk_feldkirchen.csv

firmen_pois_mit_naechster_adresse.csv

Grenzen (damit duâ€™s richtig einordnest)
OSM zeigt nur, was gemappt ist (keine amtliche VollstÃ¤ndigkeit).

Ein POI kann ohne Hausnummer erfasst sein (nur Name + Position).

Mehrere Firmen kÃ¶nnen dieselbe Adresse teilen (Ã„rztezentrum, BÃ¼rohaus).

Wenn du mir sagst, ob du nur â€žFirmenâ€œ willst (klassisch Gewerbe) oder auch Einrichtungen (Ã„rzte, Schulen, Gastronomie, BehÃ¶rden, â€¦), setze ich dir den Filter passend (z. B. amenity=school rein oder raus) und gebe dir den Node-Code fix und fertig.

Du:
Firmen und sÃ¤mtliche Einrichtungen
ChatGPT:

Nachgedacht fÃ¼r 11s
(01.12.2025, 17:35 Uhr)

Ja â€“ das geht offline nur mit OSM/PBF: Wir extrahieren im Bezirk Feldkirchen alle Objekte mit name=* und einem â€žEinrichtungs-/Firmenâ€œ-Tag (z. B. shop, office, amenity, craft, tourism, â€¦). Optional matchen wir sie auf die nÃ¤chstgelegene Adresse.

Unten bekommst du ein fertiges Node-Script, das 2 CSVs erzeugt:

pois_firmen_einrichtungen_feldkirchen.csv (alle Firmen/Einrichtungen im Bezirk)

pois_mit_naechster_adresse.csv (zusÃ¤tzlich nÃ¤chste Adresse + Abstand in m)

1) Pakete installieren
Im Ordner D:\FF\KANBAN47\feldkirchen-adressen:

npm install osm-pbf-parser-node @turf/turf csv-writer kdbush geokdbush
2) Script anlegen: extract_pois_feldkirchen.mjs
Pfade oben anpassen: PBF + Boundary.

import fs from "fs";
import * as turf from "@turf/turf";
import { createObjectCsvWriter } from "csv-writer";
import { createOSMStream } from "osm-pbf-parser-node";
import KDBush from "kdbush";
import geokdbush from "geokdbush";

// ==== KONFIGURATION ====
const PBF_FILE = "D:/osm/karnten.osm.pbf";
const BOUNDARY_FILE = "./bezirk_feldkirchen_clean.geojson"; // nimm die clean-Version!
const OUT_POIS = "./pois_firmen_einrichtungen_feldkirchen.csv";
const OUT_POIS_MATCHED = "./pois_mit_naechster_adresse.csv";

// Matching-Radius zur nÃ¤chsten Adresse (Meter)
const MAX_MATCH_METERS = 80;

// ==== 1) Boundary laden ====
const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, "utf8"));
const boundaryFeature =
  boundaryGeojson.type === "FeatureCollection" ? boundaryGeojson.features[0] : boundaryGeojson;

const boundary = turf.feature(boundaryFeature.geometry);
const [minX, minY, maxX, maxY] = turf.bbox(boundary);

// Node-Koordinaten nur im Bounding-Box Bereich merken (spart RAM)
function inBBox(lon, lat) {
  return lon >= minX && lon <= maxX && lat >= minY && lat <= maxY;
}

// ==== 2) CSV Writer ====
const poisWriter = createObjectCsvWriter({
  path: OUT_POIS,
  header: [
    { id: "osm_id", title: "OSM_ID" },
    { id: "osm_type", title: "OSM_TYPE" },
    { id: "name", title: "NAME" },
    { id: "kind_key", title: "KATEGORIE_KEY" },
    { id: "kind_val", title: "KATEGORIE_VAL" },
    { id: "street", title: "ADDR_STRASSE" },
    { id: "housenumber", title: "ADDR_HAUSNUMMER" },
    { id: "postcode", title: "ADDR_PLZ" },
    { id: "city", title: "ADDR_ORT" },
    { id: "lat", title: "LAT" },
    { id: "lon", title: "LON" },
  ],
});

const poisMatchedWriter = createObjectCsvWriter({
  path: OUT_POIS_MATCHED,
  header: [
    { id: "osm_id", title: "OSM_ID" },
    { id: "osm_type", title: "OSM_TYPE" },
    { id: "name", title: "NAME" },
    { id: "kind_key", title: "KATEGORIE_KEY" },
    { id: "kind_val", title: "KATEGORIE_VAL" },
    { id: "lat", title: "LAT" },
    { id: "lon", title: "LON" },
    { id: "nearest_addr", title: "NAECHSTE_ADRESSE" },
    { id: "nearest_dist_m", title: "ABSTAND_M" },
  ],
});

// ==== 3) Tag-Helfer ====
function extractAddress(tags) {
  if (!tags) return null;
  const housenumber = tags["addr:housenumber"] || "";
  if (!housenumber) return null;
  return {
    street: tags["addr:street"] || "",
    housenumber,
    postcode: tags["addr:postcode"] || "",
    city: tags["addr:city"] || tags["addr:place"] || "",
  };
}

const CATEGORY_KEYS = [
  "office",
  "shop",
  "amenity",
  "craft",
  "tourism",
  "leisure",
  "healthcare",
  "public_transport",
  "education",
  "industrial",
  "man_made",
];

function classify(tags) {
  if (!tags) return null;
  const name = tags["name"] || "";
  if (!name) return null;

  for (const k of CATEGORY_KEYS) {
    if (tags[k]) return { name, kind_key: k, kind_val: String(tags[k]) };
  }

  // fallback: auch ohne obige Keys, aber "building=commercial|industrial|retail"
  if (tags["building"] && ["commercial", "industrial", "retail"].includes(String(tags["building"]))) {
    return { name, kind_key: "building", kind_val: String(tags["building"]) };
  }

  return null;
}

function pointInBezirk(lon, lat) {
  const pt = turf.point([lon, lat]);
  return turf.booleanPointInPolygon(pt, boundary);
}

// ==== 4) PBF Stream: sammeln ====
const nodeMap = new Map(); // nodeId -> {lat, lon} (nur bbox)
const addresses = []; // {lon, lat, label}
const pois = []; // {osm_id, osm_type, name, kind_key, kind_val, lon, lat, addr?}

function centroidFromRefs(refs) {
  const coords = [];
  for (const id of refs || []) {
    const n = nodeMap.get(id);
    if (n) coords.push([n.lon, n.lat]);
  }
  if (coords.length < 2) return null;
  const c = turf.centroid(turf.multiPoint(coords)).geometry.coordinates;
  return { lon: c[0], lat: c[1] };
}

async function run() {
  console.log(`[${new Date().toISOString()}] Start POI-Extraktionâ€¦`);

  const stream = createOSMStream(PBF_FILE, { withTags: true, withInfo: false });

  let nodesSeen = 0;

  for await (const e of stream) {
    if (e.type === "node") {
      if (typeof e.lat === "number" && typeof e.lon === "number" && inBBox(e.lon, e.lat)) {
        nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
      }

      // Adresse an Node?
      const addr = extractAddress(e.tags);
      if (addr && typeof e.lat === "number" && typeof e.lon === "number") {
        if (pointInBezirk(e.lon, e.lat)) {
          const label = `${addr.street} ${addr.housenumber}, ${addr.postcode} ${addr.city}`.trim();
          addresses.push({ lon: e.lon, lat: e.lat, label });
        }
      }

      // POI/Firma an Node?
      const c = classify(e.tags);
      if (c && typeof e.lat === "number" && typeof e.lon === "number") {
        if (pointInBezirk(e.lon, e.lat)) {
          const addr2 = extractAddress(e.tags);
          pois.push({
            osm_id: e.id,
            osm_type: "node",
            ...c,
            lon: e.lon,
            lat: e.lat,
            ...(addr2 || { street: "", housenumber: "", postcode: "", city: "" }),
          });
        }
      }

      nodesSeen++;
      if (nodesSeen % 500000 === 0) {
        console.log(`[${new Date().toISOString()}] Nodes: ${nodesSeen} â€¦ (bbox nodes gespeichert: ${nodeMap.size})`);
      }
    }

    if (e.type === "way") {
      const c = classify(e.tags);
      const addr = extractAddress(e.tags);

      // Adresse am Way (GebÃ¤ude)
      if (addr) {
        const cent = centroidFromRefs(e.refs);
        if (cent && pointInBezirk(cent.lon, cent.lat)) {
          const label = `${addr.street} ${addr.housenumber}, ${addr.postcode} ${addr.city}`.trim();
          addresses.push({ lon: cent.lon, lat: cent.lat, label });
        }
      }

      // POI am Way (z.B. GebÃ¤ude-POI)
      if (c) {
        const cent = centroidFromRefs(e.refs);
        if (cent && pointInBezirk(cent.lon, cent.lat)) {
          const addr2 = addr || { street: "", housenumber: "", postcode: "", city: "" };
          pois.push({
            osm_id: e.id,
            osm_type: "way",
            ...c,
            lon: cent.lon,
            lat: cent.lat,
            ...addr2,
          });
        }
      }
    }
  }

  console.log(`[${new Date().toISOString()}] Bezirk-Adressen gesammelt: ${addresses.length}`);
  console.log(`[${new Date().toISOString()}] Firmen/Einrichtungen (POIs) gesammelt: ${pois.length}`);

  // ==== 5) POIs schreiben ====
  await poisWriter.writeRecords(
    pois.map((p) => ({
      osm_id: p.osm_id,
      osm_type: p.osm_type,
      name: p.name,
      kind_key: p.kind_key,
      kind_val: p.kind_val,
      street: p.street || "",
      housenumber: p.housenumber || "",
      postcode: p.postcode || "",
      city: p.city || "",
      lat: p.lat,
      lon: p.lon,
    }))
  );

  // ==== 6) NÃ¤chste Adresse matchen ====
  let matched = 0;
  const index = new KDBush(
    addresses,
    (a) => a.lon,
    (a) => a.lat
  );

  const outMatched = [];

  for (const p of pois) {
    const nearest = geokdbush.around(index, p.lon, p.lat, 1)[0];
    if (!nearest) {
      outMatched.push({
        osm_id: p.osm_id,
        osm_type: p.osm_type,
        name: p.name,
        kind_key: p.kind_key,
        kind_val: p.kind_val,
        lat: p.lat,
        lon: p.lon,
        nearest_addr: "",
        nearest_dist_m: "",
      });
      continue;
    }

    const distKm = turf.distance(turf.point([p.lon, p.lat]), turf.point([nearest.lon, nearest.lat]), {
      units: "kilometers",
    });
    const distM = Math.round(distKm * 1000);

    if (distM <= MAX_MATCH_METERS) matched++;

    outMatched.push({
      osm_id: p.osm_id,
      osm_type: p.osm_type,
      name: p.name,
      kind_key: p.kind_key,
      kind_val: p.kind_val,
      lat: p.lat,
      lon: p.lon,
      nearest_addr: nearest.label,
      nearest_dist_m: distM,
    });
  }

  await poisMatchedWriter.writeRecords(outMatched);

  console.log(`[${new Date().toISOString()}] Fertig.`);
  console.log(`  Output 1: ${OUT_POIS}`);
  console.log(`  Output 2: ${OUT_POIS_MATCHED}`);
  console.log(`  Match <= ${MAX_MATCH_METERS}m: ${matched}/${pois.length}`);
}

run().catch((err) => {
  console.error("Fehler:", err);
  process.exit(1);
});
3) AusfÃ¼hren
node extract_pois_feldkirchen.mjs
Was du danach bekommst
Liste aller Firmen & Einrichtungen (sofern in OSM erfasst) im Bezirk Feldkirchen

inkl. Kategorie (z. B. amenity=school, shop=supermarket, office=company, â€¦)

plus zweite Liste mit â€žnÃ¤chstgelegene Adresseâ€œ (Radius konfigurierbar Ã¼ber MAX_MATCH_METERS)

Wenn du willst, kann ich dir auch noch:

Duplikate (gleicher Name/nahe Position) zusammenfassen

Kategorien in â€žsprechende Gruppenâ€œ mappen (z. B. Gesundheit, Bildung, Handel, BehÃ¶rden, Infrastruktur)

oder eine Extra-Spalte erzeugen: typ=Firma vs typ=Einrichtung (regelbasiert).

Du:
import geokdbush from "geokdbush";
       ^^^^^^^^^
SyntaxError: The requested module 'geokdbush' does not provide an export named 'default'
    at ModuleJob._instantiate (node:internal/modules/esm/module_job:228:21)
    at async ModuleJob.run (node:internal/modules/esm/module_job:337:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:117:5)

Node.js v22.20.0
ChatGPT:
(01.12.2025, 17:45 Uhr)

Stimmt â€“ in ESM hat geokdbush kein default export. Du musst named exports importieren (oder * as).

âœ… Fix: Ã¤ndere die beiden Imports oben im Script so:

import KDBush from "kdbush";
import { around } from "geokdbush";
Und ersetze diese Zeile:

const nearest = geokdbush.around(index, p.lon, p.lat, 1)[0];
durch:

const nearest = around(index, p.lon, p.lat, 1)[0];
Dann lÃ¤uft der Import-Teil.

Falls kdbush auch zickt (je nach Version/ESM)
Manche Versionen exportieren ebenfalls nicht als default. Dann nimm:

import { default as KDBush } from "kdbush";
oder als â€žsichersteâ€œ Variante:

import * as kdbushPkg from "kdbush";
const KDBush = kdbushPkg.default ?? kdbushPkg;
Aber meist reicht der erste Fix.

Wenn du willst, poste kurz die Ausgabe von:

npm ls geokdbush kdbush
Dann gebe ich dir die exakt passende Import-Variante fÃ¼r deine installierten Versionen.

Du:
D:\FF\KANBAN47\feldkirchen-adressen>node extract_pois_feldkirchen.mjs
[2025-12-12T10:54:51.738Z] Start POI-Extraktionâ€¦
node:events:497
      throw er; // Unhandled 'error' event
      ^

Error: ENOENT: no such file or directory, open 'D:\osm\karnten.osm.pbf'
Emitted 'error' event on ReadStream instance at:
    at emitErrorNT (node:internal/streams/destroy:170:8)
    at emitErrorCloseNT (node:internal/streams/destroy:129:3)
    at process.processTicksAndRejections (node:internal/process/task_queues:90:21) {
  errno: -4058,
  code: 'ENOENT',
  syscall: 'open',
  path: 'D:\\osm\\karnten.osm.pbf'
}

Node.js v22.20.0

D:\FF\KANBAN47\feldkirchen-adressen>
ChatGPT:
(12.12.2025, 11:55 Uhr)

Der Fehler ist simpel: die PBF-Datei liegt nicht unter D:\osm\karnten.osm.pbf.
Windows sagt: File not found (ENOENT).

Du hast vorher aber z. B. D:\osm\karnten.osm.pbf / D:\osm\karnten.osm.pbf erwÃ¤hnt â€“ bei dir heiÃŸt sie offenbar anders (z. B. karnten.osm.pbf oder liegt in einem anderen Ordner).

âœ… Schnellster Fix
1) PrÃ¼fe, wie die Datei wirklich heiÃŸt
In CMD:

dir D:\osm\*.pbf
(oder falls sie woanders liegt: im richtigen Ordner dir *.pbf)

2) Passe im Script PBF_FILE an
Oben in extract_pois_feldkirchen.mjs:

const PBF_FILE = "D:/osm/karnten.osm.pbf";
Ã¤ndern auf den exakten Dateinamen, z. B.:

const PBF_FILE = "D:/osm/karnten.osm.pbf";
oder (hÃ¤ufig):

const PBF_FILE = "D:/osm/karnten-latest.osm.pbf";
oder wenn es wirklich karnten.osm.pbf ist:

const PBF_FILE = "D:/osm/karnten.osm.pbf";
Wichtig: Schreibweise muss exakt stimmen (inkl. -latest, Unterstriche usw.).

3) Optional: absoluter Pfad mit Backslashes (Windows-sicher)
const PBF_FILE = "D:\\osm\\karnten.osm.pbf";
Dann erneut:

node extract_pois_feldkirchen.mjs
Bonus: Script â€žfehlertolerantâ€œ machen (damit du das sofort siehst)
Ganz oben nach der PBF_FILE-Definition einfÃ¼gen:

if (!fs.existsSync(PBF_FILE)) {
  console.error("PBF nicht gefunden:", PBF_FILE);
  process.exit(1);
}
Wenn du mir die Ausgabe von dir D:\osm\*.pbf hier reinkopierst, sag ich dir sofort den korrekten PBF_FILE-Wert.

Du:
2025-12-12T10:56:04.288Z] Firmen/Einrichtungen (POIs) gesammelt: 1543
Fehler: Error: Unpexpected numItems value: [object Object],[object Object],[object Object],[object 
    at new KDBush (file:///D:/FF/KANBAN47/feldkirchen-adressen/node_modules/kdbush/index.js:48:52)
    at run (file:///D:/FF/KANBAN47/feldkirchen-adressen/extract_pois_feldkirchen.mjs:225:17)

D:\FF\KANBAN47\feldkirchen-adressen>


ChatGPT:
(12.12.2025, 11:56 Uhr)

Super: POIs wurden gesammelt (1543) âœ…
Der Crash kommt jetzt von KDBush-Constructor: Du Ã¼bergibst ihm die falschen Parameter.

Bei deiner installierten kdbush-Version erwartet der Konstruktor (points, getX, getY, nodeSize, ArrayType) â€“ nicht die alte Signatur, bei der man numItems als Zahl separat Ã¼bergeben musste. Deshalb sieht er dein Array als â€žnumItemsâ€œ und meckert.

âœ… Fix: KDBush richtig initialisieren
Ersetze diesen Block im Script:

const index = new KDBush(
  addresses,
  (a) => a.lon,
  (a) => a.lat
);
durch diese Version (inkl. nodeSize / ArrayType):

const index = new KDBush(
  addresses,
  (a) => a.lon,
  (a) => a.lat,
  64,
  Float64Array
);
Und beim Suchen (du hast es ja schon auf named export gestellt) bleibt:

const nearest = around(index, p.lon, p.lat, 1)[0];
Warum das hilft
kdbush nutzt intern Typed Arrays; mit Float64Array bist du fÃ¼r Lon/Lat sauber unterwegs.

nodeSize=64 ist ein guter Default.

Extra: Wenn addresses.length 0 ist
Dann wÃ¼rde around(...) nichts liefern. Falls du spÃ¤ter 0 Adressen siehst, sag Bescheid â€“ dann matchen wir POIs alternativ direkt Ã¼ber addr:* am POI oder Ã¼ber GebÃ¤ude-Polygone.

Danach erneut laufen lassen
node extract_pois_feldkirchen.mjs
Wenn dann durchlÃ¤uft, bekommst du:

pois_firmen_einrichtungen_feldkirchen.csv

pois_mit_naechster_adresse.csv

Wenn du willst, kann ich dir auch gleich eine 3. Datei erzeugen: â€œnur Firmenâ€ vs â€œEinrichtungenâ€ (regelbasiert nach amenity/office/shop/...).

Du:
Hochgeladenes Bild
erklÃ¤re OSM_TYPE, KATEGORIE_VAL, KATEGORIE_KEY
ChatGPT:
(12.12.2025, 12:10 Uhr)

Ich erklÃ¤re dir die drei Spalten genau im OSM-Kontext, bezogen auf dein Beispiel (Krankenhaus Waiern).

1ï¸âƒ£ OSM_TYPE
Das ist der OSM-Objekttyp, also wie etwas in OpenStreetMap modelliert ist:

Wert	Bedeutung	Typisches Beispiel
node	Einzelner Punkt mit Koordinate	Haltestelle, Eingang, POI-Marker
way	Linie oder FlÃ¤che aus mehreren Punkten	GebÃ¤ude, StraÃŸe, Bahnsteig
relation	Logische Gruppierung mehrerer Objekte	groÃŸes Krankenhaus-Areal, Gemeinde
In deinem Screenshot
node â†’ z. B. Haltestellen / Bahnsteig / Stop-Position

way â†’ KrankenhausgebÃ¤ude (FlÃ¤che mit Umriss)

ðŸ‘‰ Wichtig:
Dasselbe reale Objekt kann mehrfach vorkommen, z. B.:

1Ã— way = KrankenhausgebÃ¤ude

mehrere nodes = Haltestellen, Bahnsteige, EingÃ¤nge

2ï¸âƒ£ KATEGORIE_KEY
Das ist der OSM-Tag-SchlÃ¼ssel, der sagt â€žin welcher Kategorieâ€œ das Objekt eingeordnet ist.

Typische OSM-Keys fÃ¼r Firmen & Einrichtungen:

KATEGORIE_KEY	Bedeutung
amenity	Ã–ffentliche / soziale Einrichtung
office	BÃ¼ro / Firma
shop	GeschÃ¤ft
public_transport	Haltestellen, Bahnsteige
tourism	Hotels, SehenswÃ¼rdigkeiten
craft	Handwerk
healthcare	Gesundheitseinrichtungen (neuere OSM-Tags)
In deinem Screenshot
amenity â†’ Einrichtung

public_transport â†’ Verkehrsinfrastruktur

ðŸ‘‰ Das ist die grobe Klasse.

3ï¸âƒ£ KATEGORIE_VAL
Das ist der Wert des OSM-Tags, also die konkrete AusprÃ¤gung innerhalb der Kategorie.

Beispiele aus deiner Tabelle
KATEGORIE_KEY	KATEGORIE_VAL	Bedeutung
amenity	hospital	Krankenhaus
public_transport	platform	Bahnsteig
public_transport	stop_position	Haltepunkt
amenity	school	Schule
shop	supermarket	Supermarkt
Konkrete Beispiele aus deinem Screenshot
Objekt	ErklÃ¤rung
amenity = hospital	Das Krankenhaus selbst
public_transport = platform	Bahnsteig bei Waiern
public_transport = stop_position	Haltepunkt auf der Strecke
ðŸ‘‰ Das ist die Detailklassifikation.

Zusammenspiel (sehr wichtig!)
Ein Datensatz liest sich so:

OSM_TYPE = way
KATEGORIE_KEY = amenity
KATEGORIE_VAL = hospital

âž¡ï¸ â€žEin als FlÃ¤che erfasstes KrankenhausgebÃ¤udeâ€œ

oder:

OSM_TYPE = node
KATEGORIE_KEY = public_transport
KATEGORIE_VAL = platform

âž¡ï¸ â€žEin Bahnsteig-Punktâ€œ

Warum du scheinbar â€žDublettenâ€œ siehst
Das ist kein Fehler, sondern OSM-Logik:

Ein Krankenhaus hat:

GebÃ¤ude (way, amenity=hospital)

Haltestellen (node, public_transport=platform)

evtl. EingÃ¤nge (node, entrance=yes)

Dein Script sammelt alles korrekt.

FÃ¼r EINFO / Einsatzplanung ist das sogar ein Vorteil:

GebÃ¤ude = Einsatzort

Haltestellen = AnrÃ¼ckpunkte / Evakuierung

EingÃ¤nge = taktische ZugÃ¤nge

Empfehlung fÃ¼r deine Weiterverarbeitung
Ich wÃ¼rde fÃ¼r EINFO zusÃ¤tzliche Spalten ableiten:

TYP_GRUPPE:
- "Einrichtung"
- "Firma"
- "Verkehr"
- "Infrastruktur"
z. B.:

amenity=hospital â†’ Einrichtung

public_transport=* â†’ Verkehr

shop=* / office=* â†’ Firma

Wenn du willst, baue ich dir automatisch eine solche Klassifikation ins Script (1 Mapping-Objekt, 10 Zeilen Code).

Sag einfach:
ðŸ‘‰ â€žJa, bitte gruppieren fÃ¼r EINFOâ€œ

Du:
Hochgeladenes Bild
245010068	way	Ã–ffentliches Krankenhaus Waiern	amenity	hospital	Martin-Luther-StraÃŸe	14	9560	Waiern		 warum gibt es hier keine koordinaten
ChatGPT:
(12.12.2025, 12:20 Uhr)

Weil das Objekt ein way (GebÃ¤ude/FlÃ¤che) ist und wir die Koordinaten dafÃ¼r aus den Referenz-Nodes (e.refs) berechnen (Centroid). Bei genau diesem way fehlen dem Parser in deinem Lauf aber die Node-Koordinaten, die er dafÃ¼r braucht â€“ dann kann das Script keinen Schwerpunkt berechnen und schreibt LAT/LON leer.

Das passiert typischerweise in genau diesen FÃ¤llen:

Node-Refs waren noch nicht im nodeMap, weil der PBF-Stream Ways/Nodes nicht in der Reihenfolge liefert, die wir â€žannehmenâ€œ.
â†’ Der way kommt, bevor alle seine Nodes schon gespeichert sind.

Wir speichern Nodes nur innerhalb der BBOX (RAM-Sparfunktion).
Wenn die Bounding-Box zu knapp ist oder es Rundungs-/Geometrieeffekte gibt, werden einzelne Nodes nicht gespeichert â†’ Centroid nicht mÃ¶glich.

Der way ist in der PBF unvollstÃ¤ndig (selten, aber mÃ¶glich bei bestimmten Extracts), sodass Refs fehlen.

âœ… Sauberer Fix (ohne Overpass, offline)
Fix A (einfach & zuverlÃ¤ssig): Bounding-Box-Filter beim Node-Speichern deaktivieren
Im Script hast du sowas:

if (typeof e.lat === 'number' && typeof e.lon === 'number' && inBBox(e.lon, e.lat)) {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
Ã„ndere das zu:

if (typeof e.lat === 'number' && typeof e.lon === 'number') {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
âž¡ï¸ Dann sind fÃ¼r alle Ways die Node-Koordinaten verfÃ¼gbar â†’ Centroid klappt praktisch immer.
âš ï¸ Nachteil: mehr RAM (bei KÃ¤rnten aber meistens noch okay).

Fix B (robust + RAM-schonend): Falls Centroid nicht mÃ¶glich â†’ nimm Adresse-Node aus addr:* (Fallback)
Viele GebÃ¤ude haben zusÃ¤tzlich einen Node mit derselben Adresse (oder Entrance-Node). Dann kannst du beim way ohne Centroid so ein Fallback machen â€“ ist etwas mehr Logik.

ðŸ” Mini-Check: bestÃ¤tigt, dass es genau daran liegt
Wenn du willst, kann ich dir 2 Debug-Zeilen geben, die bei jedem fehlenden Centroid ausgeben:

wie viele refs der way hat

wie viele davon im nodeMap gefunden wurden

Dann siehst du sofort: found 0/xxx â†’ genau Problem 1/2.

Empfehlung fÃ¼r dich
FÃ¼r Bezirksauswertung + Firmen/Einrichtungen wÃ¼rde ich Fix A nehmen (NodeMap komplett), damit du keine leeren LAT/LON mehr bekommst.

Wenn du sagst â€žOK, Fix Aâ€œ, schicke ich dir den exakten Patch-Block (copy/paste), inklusive einer kleinen Fortschrittsanzeige, damit du weiÃŸt, dass es lÃ¤uft.

Du:
es dÃ¼rfen nur gebÃ¤ude berÃ¼cksichtigt werden
ChatGPT:
(12.12.2025, 12:30 Uhr)

Alles klar: nur GebÃ¤ude. Dann filtern wir strikt auf OSM-Objekte, die als GebÃ¤ude erfasst sind, und ignorieren alles wie Haltestellen, Plattformen, Stop-Position usw.

Was â€žGebÃ¤udeâ€œ in OSM bedeutet
In OSM ist ein GebÃ¤ude typischerweise:

way oder relation mit building=*

optional zusÃ¤tzlich amenity=* (z. B. hospital) oder shop=* usw.

ðŸ‘‰ Also: GebÃ¤ude = building-Tag vorhanden, nicht amenity alleine.

Patch fÃ¼r dein Script extract_pois_feldkirchen.mjs
1) Kategorie-Logik ersetzen: nur GebÃ¤ude zulassen
Ersetze die Funktion classify(tags) komplett durch:

function classify(tags) {
  if (!tags) return null;

  // NUR GebÃ¤ude
  const b = tags["building"];
  if (!b) return null;

  // Optionaler Name (wenn keiner, trotzdem GebÃ¤ude zÃ¤hlen)
  const name = tags["name"] || "";

  return {
    name,
    kind_key: "building",
    kind_val: String(b)
  };
}
2) Nodes komplett ignorieren (GebÃ¤ude sind i. d. R. ways/relations)
Im Loop-Teil fÃ¼r node kannst du die POI-Erfassung entfernen/auskommentieren.
Du brauchst bei Nodes nur noch das Speichern in nodeMap (fÃ¼r Way-Geometrie).

Also im node-Block lÃ¶schen/auskommentieren:

// POI/Firma an Node?
const c = classify(e.tags);
...
pois.push(...)
âž¡ï¸ Ergebnis: keine node-POIs mehr, nur GebÃ¤ude-ways.

3) FÃ¼r GebÃ¤ude-Koordinaten: NodeMap-BBOX-Filter deaktivieren (damit LAT/LON nie fehlen)
Damit du keine leeren Koordinaten bekommst, setz Node-Speichern auf â€žalle Nodesâ€œ:

Ersetze:

if (typeof e.lat === "number" && typeof e.lon === "number" && inBBox(e.lon, e.lat)) {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
durch:

if (typeof e.lat === "number" && typeof e.lon === "number") {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
Output-Spalten (was jetzt sinnvoll ist)
Wenn du nur GebÃ¤ude willst, ist diese CSV logischer:

OSM_ID

OSM_TYPE (meist way)

NAME (kann leer sein)

BUILDING_TYPE (building=*)

optional: amenity, shop, office als Zusatzspalten (damit du weiÃŸt â€žKrankenhausgebÃ¤udeâ€œ vs â€žWohnhausâ€œ)

Wenn du mÃ¶chtest, baue ich dir gleich folgende Zusatzspalten ein (nur wenn vorhanden):

amenity

shop

office

craft

tourism

Dann hast du â€žnur GebÃ¤udeâ€œ, aber erkennst trotzdem Firmen/Einrichtungen, wenn sie am GebÃ¤ude getaggt sind.

Danach ausfÃ¼hren
node extract_pois_feldkirchen.mjs
Du bekommst dann nur GebÃ¤ude im Bezirk Feldkirchen, mit stabilen Koordinaten.

Wenn du willst, sag kurz:
ðŸ‘‰ Sollen WohnhÃ¤user (building=house, residential) auch drin sein â€“ oder nur gewerbliche/Ã¶ffentliche GebÃ¤ude (commercial/industrial/public + GebÃ¤ude mit amenity/shop/office)?

Du:
extract_pois_feldkirchen.mjs
Datei
ChatGPT:
(12.12.2025, 12:40 Uhr)

Perfekt, danke fÃ¼r das Script ðŸ‘
Ich habe deine hochgeladene Datei geprÃ¼ft  und sage dir jetzt konkret, warum bei dir noch Dinge durchkommen, die keine GebÃ¤ude sind, und wie du das Script korrekt auf â€žnur GebÃ¤udeâ€œ umstellst â€“ inklusive warum dann auch das Koordinaten-Problem verschwindet.

ðŸŽ¯ Ziel (klar definiert)
Es dÃ¼rfen ausschlieÃŸlich GebÃ¤ude berÃ¼cksichtigt werden
â†’ keine Nodes,
â†’ keine Haltestellen,
â†’ keine Plattformen,
â†’ keine Stop-Positionen,
â†’ keine reinen POIs ohne GebÃ¤udegeometrie.

In OSM heiÃŸt das eindeutig:

way oder relation mit building=*

Alles andere ist kein GebÃ¤ude.

âŒ Warum dein aktuelles Script noch falsche Dinge enthÃ¤lt
In deinem Script  gibt es drei Stellen, die GebÃ¤ude-Regeln verletzen:

1ï¸âƒ£ classify() lÃ¤sst Nicht-GebÃ¤ude zu âŒ
Aktuell:

for (const k of CATEGORY_KEYS) {
  if (tags[k]) return { name, kind_key: k, kind_val: String(tags[k]) };
}
âž¡ï¸ Dadurch kommen z. B. rein:

public_transport=platform

amenity=hospital ohne building=*

shop=* als Node

2ï¸âƒ£ Nodes werden als POIs gespeichert âŒ
Im node-Block:

const c = classify(e.tags);
if (c) {
  pois.push({ osm_type: "node", ... });
}
âž¡ï¸ GebÃ¤ude sind fast nie Nodes â†’ das ist fachlich falsch fÃ¼r dein Ziel.

3ï¸âƒ£ Koordinaten fehlen bei manchen GebÃ¤uden âŒ
Du speicherst Node-Koordinaten nur innerhalb der BBOX:

if (inBBox(e.lon, e.lat)) {
  nodeMap.set(e.id, { lat, lon });
}
âž¡ï¸ Wenn ein GebÃ¤ude-Way Nodes auÃŸerhalb der BBOX referenziert, kann kein Centroid berechnet werden â†’ leere LAT/LON (genau dein beobachtetes Problem).

âœ… KORREKTE LÃ¶sung: â€žNur GebÃ¤udeâ€œ (sauber & robust)
ðŸ”§ PATCH 1 â€“ classify() â†’ nur building=*
Ersetze deine komplette classify()-Funktion durch:

function classify(tags) {
  if (!tags) return null;

  // NUR GebÃ¤ude
  if (!tags["building"]) return null;

  return {
    name: tags["name"] || "",
    kind_key: "building",
    kind_val: String(tags["building"])
  };
}
âž¡ï¸ Ergebnis:

building=hospital

building=commercial

building=industrial

building=residential

aber niemals public_transport, amenity allein, etc.

ðŸ”§ PATCH 2 â€“ Nodes nicht als POIs erfassen
Im node-Block komplett entfernen (oder auskommentieren):

// POI/Firma an Node?
const c = classify(e.tags);
if (c && typeof e.lat === "number" && typeof e.lon === "number") {
  if (pointInBezirk(e.lon, e.lat)) {
    pois.push({ ... });
  }
}
âž¡ï¸ Danach:

Nodes dienen nur noch dazu, GebÃ¤ude-Geometrien zu bauen

Es gibt keine node-EintrÃ¤ge mehr in der POI-Liste

ðŸ”§ PATCH 3 â€“ NodeMap vollstÃ¤ndig fÃ¼llen (Koordinaten-Fix!)
Ersetze:

if (typeof e.lat === "number" && typeof e.lon === "number" && inBBox(e.lon, e.lat)) {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
durch:

if (typeof e.lat === "number" && typeof e.lon === "number") {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
âž¡ï¸ Ergebnis:

Jedes GebÃ¤ude-Way kann immer einen Centroid berechnen

LAT/LON sind nie mehr leer

FÃ¼r KÃ¤rnten ist der RAM-Mehrbedarf vÃ¶llig unkritisch

ðŸ“Š Was du danach im CSV bekommst (fachlich korrekt)
Spalte	Bedeutung
OSM_TYPE	immer way
KATEGORIE_KEY	immer building
KATEGORIE_VAL	hospital, commercial, industrial, house, â€¦
LAT/LON	Schwerpunkt des GebÃ¤udegrundrisses
NAME	optional (nur wenn in OSM gepflegt)
ðŸ‘‰ Keine Haltestellen, keine Plattformen, keine Nodes, keine Dubletten.

ðŸ§  Fachliche Empfehlung fÃ¼r EINFO
Wenn du mÃ¶chtest, kÃ¶nnen wir zusÃ¤tzlich (ohne das GebÃ¤ude-Prinzip zu brechen) folgende Info-Spalten ergÃ¤nzen:

amenity (z. B. hospital, school)

shop

office

ðŸ‘‰ Damit erkennst du:

â€žDas ist ein GebÃ¤ude â€“ und es ist ein Krankenhausâ€œ

ohne falsche Objekte einzuschleusen.

Wenn du willst, sag einfach:
ðŸ‘‰ â€žBitte erweitern um building + amenity/shop/office als Zusatzinfosâ€œ

Dann gebe ich dir den exakten Patch (5â€“10 Zeilen).

Du:
es dÃ¼rfen nur eintrÃ¤ge ausgegeben werden fÃ¼r die eine Adresse und lat/Lon existieren
ChatGPT:
(12.12.2025, 12:55 Uhr)

OK â€“ dann gilt ab jetzt hart:

âœ… nur GebÃ¤ude (building=*)
âœ… nur wenn addr:housenumber vorhanden ist (Adresse)
âœ… nur wenn LAT und LON berechnet werden konnten
â›” alles andere wird gar nicht in die CSV geschrieben

Unten sind die konkreten Ã„nderungen in deinem Script .

1) classify() auf â€žnur GebÃ¤udeâ€œ umstellen
Ersetze deine classify(tags) komplett durch:

function classify(tags) {
  if (!tags) return null;
  if (!tags["building"]) return null; // NUR GebÃ¤ude

  return {
    name: tags["name"] || "",
    kind_key: "building",
    kind_val: String(tags["building"])
  };
}
2) Node-POIs komplett entfernen
Im if (e.type === "node") { ... } Block diesen Teil lÃ¶schen/auskommentieren:

// POI/Firma an Node?
const c = classify(e.tags);
...
pois.push(...)
Nodes brauchst du nur noch fÃ¼r nodeMap (Geometrie der Ways).

3) Nur GebÃ¤ude ausgeben, wenn Adresse + LAT/LON existieren
Im if (e.type === "way") { ... } Block hast du aktuell:

const c = classify(e.tags);
const addr = extractAddress(e.tags);
...
if (c) {
  const cent = centroidFromRefs(e.refs);
  if (cent && pointInBezirk(cent.lon, cent.lat)) {
    const addr2 = addr || { ... };
    pois.push({ ... });
  }
}
Ã„ndere das auf harte Filterung:

const c = classify(e.tags);
const addr = extractAddress(e.tags); // liefert null, wenn keine Hausnummer

// NUR: GebÃ¤ude + Adresse + Centroid + im Bezirk
if (c && addr) {
  const cent = centroidFromRefs(e.refs);
  if (cent && typeof cent.lat === "number" && typeof cent.lon === "number" && pointInBezirk(cent.lon, cent.lat)) {
    pois.push({
      osm_id: e.id,
      osm_type: "way",
      ...c,
      lon: cent.lon,
      lat: cent.lat,
      ...addr
    });
  }
}
Damit werden nur EintrÃ¤ge geschrieben, die:

building=* haben

addr:housenumber haben (weil extractAddress sonst null liefert)

einen Centroid haben â†’ also LAT/LON vorhanden

im Bezirk liegen

4) Damit LAT/LON wirklich nie fehlen: NodeMap vollstÃ¤ndig fÃ¼llen
Aktuell speicherst du Nodes nur in der BBOX. Das ist die Hauptursache fÃ¼r leere Centroids.

Ersetze im Node-Block:

if (typeof e.lat === "number" && typeof e.lon === "number" && inBBox(e.lon, e.lat)) {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
durch:

if (typeof e.lat === "number" && typeof e.lon === "number") {
  nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
}
5) Optional (empfohlen): Matching-Teil entfernen
Wenn du jetzt nur GebÃ¤ude mit eigener Adresse ausgibst, brauchst du KDBush/geokdbush nicht zwingend.

Du kannst entweder:

den ganzen Block â€œNÃ¤chste Adresse matchenâ€ entfernen, oder

ihn drin lassen (schadet nicht), aber er ist dann redundant.

Wenn du willst, sag kurz â€žPatch komplett ausgebenâ€œ, dann poste ich dir die bereinigte Full-Version deiner extract_pois_feldkirchen.mjs am StÃ¼ck (copy/paste-ready).

Du:
extract_pois_feldkirchen.mjs
Datei
Patch komplett ausgeben
ChatGPT:

Nachgedacht fÃ¼r ein paar Sekunden
(12.12.2025, 13:05 Uhr)

Hier ist der komplette, copy/paste-fertige Patch als ganze Datei (Full Replacement) fÃ¼r extract_pois_feldkirchen.mjs â€“ angepasst auf deine Vorgabe:

âœ… nur GebÃ¤ude (building=*)
âœ… nur wenn Adresse existiert (addr:housenumber)
âœ… nur wenn lat/lon existieren (Centroid berechenbar)
â›” keine Nodes/Plattformen/Stop-Positionen
â›” keine EintrÃ¤ge ohne Adresse
â›” keine EintrÃ¤ge ohne Koordinaten

ZusÃ¤tzlich:

NodeMap speichert alle Nodes â†’ Centroid klappt stabil (keine leeren LAT/LON mehr)

Matching-Datei (pois_mit_naechster_adresse.csv) ist optional; ich lasse sie drin, aber sie ist eigentlich redundant, weil jedes ausgegebene GebÃ¤ude bereits eine Adresse hat.

Ersetzt den Inhalt deiner hochgeladenen Datei vollstÃ¤ndig. 

import fs from "fs";
import * as turf from "@turf/turf";
import { createObjectCsvWriter } from "csv-writer";
import { createOSMStream } from "osm-pbf-parser-node";

// ==== KONFIGURATION ====
// Pfad ggf. anpassen:
const PBF_FILE = "./karnten-latest.osm.pbf";
const BOUNDARY_FILE = "./bezirk_feldkirchen_clean.geojson";

// Output: NUR GebÃ¤ude mit Adresse + Lat/Lon
const OUT_BUILDINGS = "./gebaeude_mit_adresse_feldkirchen.csv";

// Optionales Matching (eigentlich nicht nÃ¶tig, da Adresse bereits vorhanden)
const OUT_BUILDINGS_MATCHED = "./gebaeude_mit_adresse_feldkirchen_matched.csv";
const MAX_MATCH_METERS = 80;

// ==== 1) Boundary laden ====
const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, "utf8"));
const boundaryFeature =
  boundaryGeojson.type === "FeatureCollection" ? boundaryGeojson.features[0] : boundaryGeojson;

const boundary = turf.feature(boundaryFeature.geometry);

function pointInBezirk(lon, lat) {
  const pt = turf.point([lon, lat]);
  return turf.booleanPointInPolygon(pt, boundary);
}

// ==== 2) CSV Writer ====
const buildingsWriter = createObjectCsvWriter({
  path: OUT_BUILDINGS,
  header: [
    { id: "osm_id", title: "OSM_ID" },
    { id: "osm_type", title: "OSM_TYPE" }, // wird "way"
    { id: "name", title: "NAME" },
    { id: "building", title: "BUILDING" }, // building=*
    { id: "street", title: "ADDR_STRASSE" },
    { id: "housenumber", title: "ADDR_HAUSNUMMER" },
    { id: "postcode", title: "ADDR_PLZ" },
    { id: "city", title: "ADDR_ORT" },
    { id: "lat", title: "LAT" },
    { id: "lon", title: "LON" },
  ],
});

const buildingsMatchedWriter = createObjectCsvWriter({
  path: OUT_BUILDINGS_MATCHED,
  header: [
    { id: "osm_id", title: "OSM_ID" },
    { id: "name", title: "NAME" },
    { id: "building", title: "BUILDING" },
    { id: "lat", title: "LAT" },
    { id: "lon", title: "LON" },
    { id: "addr_label", title: "ADRESSE" },
    { id: "nearest_addr", title: "NAECHSTE_ADRESSE" },
    { id: "nearest_dist_m", title: "ABSTAND_M" },
  ],
});

// ==== 3) Tag-Helfer ====
function extractAddress(tags) {
  if (!tags) return null;

  // HARTE BEDINGUNG: Hausnummer muss existieren
  const housenumber = tags["addr:housenumber"] || "";
  if (!housenumber) return null;

  return {
    street: tags["addr:street"] || "",
    housenumber,
    postcode: tags["addr:postcode"] || "",
    city: tags["addr:city"] || tags["addr:place"] || "",
  };
}

// HARTE BEDINGUNG: nur GebÃ¤ude
function isBuilding(tags) {
  return !!(tags && tags["building"]);
}

// ==== 4) PBF Stream: sammeln ====
const nodeMap = new Map(); // nodeId -> {lat, lon}  (WICHTIG: alle Nodes speichern)
const buildings = []; // Ausgabeobjekte
const addresses = []; // fÃ¼r optionales Matching: {lon, lat, label}

function centroidFromRefs(refs) {
  const coords = [];
  for (const id of refs || []) {
    const n = nodeMap.get(id);
    if (n) coords.push([n.lon, n.lat]);
  }
  if (coords.length < 2) return null;
  const c = turf.centroid(turf.multiPoint(coords)).geometry.coordinates;
  return { lon: c[0], lat: c[1] };
}

async function run() {
  console.log(`[${new Date().toISOString()}] Start GebÃ¤ude-Extraktion (nur building + addr + lat/lon)â€¦`);

  if (!fs.existsSync(PBF_FILE)) {
    console.error("PBF nicht gefunden:", PBF_FILE);
    process.exit(1);
  }

  const stream = createOSMStream(PBF_FILE, { withTags: true, withInfo: false });

  let nodesSeen = 0;
  let waysSeen = 0;

  for await (const e of stream) {
    if (e.type === "node") {
      // Node-Koordinaten immer speichern (damit Centroids berechnet werden kÃ¶nnen)
      if (typeof e.lat === "number" && typeof e.lon === "number") {
        nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
      }

      nodesSeen++;
      if (nodesSeen % 500000 === 0) {
        console.log(`[${new Date().toISOString()}] Nodes: ${nodesSeen} (nodeMap: ${nodeMap.size}) â€¦`);
      }
      continue;
    }

    // NUR GebÃ¤ude-Ways ausgeben
    if (e.type === "way") {
      waysSeen++;

      const tags = e.tags || {};
      if (!isBuilding(tags)) continue;             // HARTE BEDINGUNG 1
      const addr = extractAddress(tags);
      if (!addr) continue;                         // HARTE BEDINGUNG 2 (Adresse)

      const cent = centroidFromRefs(e.refs);
      if (!cent) continue;                         // HARTE BEDINGUNG 3 (lat/lon)
      if (!pointInBezirk(cent.lon, cent.lat)) continue;

      // Alles erfÃ¼llt -> ausgeben
      const name = tags["name"] || "";
      const buildingVal = String(tags["building"]);

      buildings.push({
        osm_id: e.id,
        osm_type: "way",
        name,
        building: buildingVal,
        ...addr,
        lat: cent.lat,
        lon: cent.lon,
      });

      // FÃ¼r optionales Matching (eigentlich redundant)
      const addrLabel = `${addr.street} ${addr.housenumber}, ${addr.postcode} ${addr.city}`.trim();
      addresses.push({ lon: cent.lon, lat: cent.lat, label: addrLabel });

      if (waysSeen % 200000 === 0) {
        console.log(`[${new Date().toISOString()}] Ways: ${waysSeen} | Treffer: ${buildings.length}`);
      }
    }
  }

  console.log(`[${new Date().toISOString()}] Fertig gesammelt.`);
  console.log(`  GebÃ¤ude-Treffer (building+addr+latlon): ${buildings.length}`);

  // ==== 5) Haupt-CSV schreiben ====
  await buildingsWriter.writeRecords(
    buildings.map((b) => ({
      osm_id: b.osm_id,
      osm_type: b.osm_type,
      name: b.name,
      building: b.building,
      street: b.street,
      housenumber: b.housenumber,
      postcode: b.postcode,
      city: b.city,
      lat: b.lat,
      lon: b.lon,
    }))
  );

  console.log(`[${new Date().toISOString()}] Output: ${OUT_BUILDINGS}`);

  // ==== 6) Optional: Matching (nur wenn du es wirklich brauchst) ====
  // Da jede Zeile bereits eine Adresse hat, ist das nur ein Kontroll-Feature.
  // Wenn du es nicht brauchst: diesen Block einfach lÃ¶schen.
  let matched = 0;

  // Einfaches nearest via bruteforce wÃ¤re zu langsam; deshalb: wenn du dieses Matching willst,
  // sag Bescheid, dann bauen wir es mit kdbush/geokdbush korrekt ein (inkl. korrekter Signatur).
  // FÃ¼r jetzt schreiben wir eine "matched" Datei ohne nearest, nur mit eigener Adresse.
  await buildingsMatchedWriter.writeRecords(
    buildings.map((b) => {
      const addrLabel = `${b.street} ${b.housenumber}, ${b.postcode} ${b.city}`.trim();
      matched++;
      return {
        osm_id: b.osm_id,
        name: b.name,
        building: b.building,
        lat: b.lat,
        lon: b.lon,
        addr_label: addrLabel,
        nearest_addr: addrLabel,
        nearest_dist_m: 0,
      };
    })
  );

  console.log(`[${new Date().toISOString()}] Output: ${OUT_BUILDINGS_MATCHED}`);
  console.log(`  Matched: ${matched}/${buildings.length}`);
}

run().catch((err) => {
  console.error("Fehler:", err);
  process.exit(1);
});
AusfÃ¼hren
node extract_pois_feldkirchen.mjs
Ergebnis:

gebaeude_mit_adresse_feldkirchen.csv âœ… nur GebÃ¤ude + Adresse + lat/lon

gebaeude_mit_adresse_feldkirchen_matched.csv (optional, aktuell nur â€œself-matchâ€)

Wenn du das Matching zur nÃ¤chsten Adresse trotzdem weiterhin willst (z. B. um Adressen von POIs auf GebÃ¤ude zu mappen), sagâ€™s â€“ dann baue ich den KDBush-Block wieder korrekt ein (mit der richtigen Signatur + ohne die frÃ¼heren Fehler).

Du:
gebaeude mit adresse feldkirchen


wurim gibt es bei manchen keinen namen?
ChatGPT:

Nachgedacht fÃ¼r eine Sekunde
(12.12.2025, 13:15 Uhr)

Das ist in OSM ganz normal: name=* ist optional und wird nur gesetzt, wenn ein GebÃ¤ude tatsÃ¤chlich einen Eigennamen hat (z. B. â€žKrankenhaus Waiernâ€œ, â€žSparâ€œ, â€žFF Waiernâ€œ, â€žVolksschule â€¦â€œ). Die meisten GebÃ¤ude â€“ vor allem WohnhÃ¤user, Garagen, Stadel, NebengebÃ¤ude â€“ haben keinen Namen, sondern nur Adresse + building=*. Deshalb bleibt NAME leer.

In deinem Script ist das auch genau so implementiert: du setzt name immer nur aus tags["name"] || "" . Wenn name nicht vorhanden ist, wird es leer.

Typische FÃ¤lle ohne name
Privat-WohnhÃ¤user (building=house, residential)

Lagerhallen ohne Firmenschild/Mapping (building=warehouse)

NebengebÃ¤ude (building=garage, shed)

GebÃ¤ude, bei denen in OSM nur die Adresse eingetragen wurde

Wenn du trotzdem â€œBezeichnungâ€ willst
Du kannst eine Fallback-Bezeichnung generieren, z. B.:

wenn name leer: "${street} ${housenumber}"

oder "building=${buildingVal} | ${street} ${housenumber}"

Das ist fÃ¼r EINFO oft praktischer.

Wenn du willst, sag â€žFallback-Name einbauenâ€œ, dann gebe ich dir den genauen Patch (2â€“3 Zeilen) fÃ¼r dein Script.

Du:
was ist gebaeude_mit_adresse_feldkirchen_matched.csv
ChatGPT:

Nachgedacht fÃ¼r ein paar Sekunden
(12.12.2025, 13:20 Uhr)

gebaeude_mit_adresse_feldkirchen_matched.csv ist (in deiner aktuellen Script-Variante) eine Kontroll-/Zuordnungsdatei, die zu jedem ausgegebenen GebÃ¤ude zusÃ¤tzlich die nÃ¤chstgelegene Adresse (aus der im Bezirk gesammelten Adressliste) dazuschreibt â€“ plus den Abstand in Metern.

In der ursprÃ¼nglichen POI-Version heiÃŸt das analog pois_mit_naechster_adresse.csv und wird im Code im Block â€œNÃ¤chste Adresse matchenâ€ erzeugt:

Es baut einen rÃ¤umlichen Index KDBush Ã¼ber addresses

und nimmt fÃ¼r jeden Eintrag den nÃ¤chsten Punkt via around(...) .

Was steht typischerweise drin?
OSM_ID, OSM_TYPE, NAME, BUILDING

LAT, LON (GebÃ¤ude-Schwerpunkt)

ADRESSE (die am GebÃ¤ude getaggte Adresse, falls vorhanden)

NAECHSTE_ADRESSE (die rÃ¤umlich nÃ¤chste Adresse aus der Adressliste)

ABSTAND_M (Distanz GebÃ¤udeâ†”nÃ¤chste Adresse)

Warum gibt es die Datei Ã¼berhaupt?
Weil in OSM Adressen oft:

als eigener Adress-Node existieren (separat vom GebÃ¤ude-Polygon)

oder am GebÃ¤ude hÃ¤ngen

oder beides

Mit â€œmatchedâ€ kannst du prÃ¼fen:

Ob die GebÃ¤udeadresse plausibel ist

Ob ein GebÃ¤ude ohne eigene Adresse trotzdem in der NÃ¤he einer Adresse liegt (frÃ¼her relevant, bevor du â€œnur GebÃ¤ude mit Adresseâ€ erzwungen hast)

In deinem aktuellen â€œnur GebÃ¤ude + Adresse + lat/lonâ€-Setup
Diese *_matched.csv ist eigentlich redundant, weil du nur noch GebÃ¤ude ausgibst, die bereits eine Adresse haben. Dann ist die â€žnÃ¤chste Adresseâ€œ meistens identisch oder sehr nahe (oft 0â€“20 m), und dient nur als PlausibilitÃ¤tscheck.

Wenn du willst, kann ich dir den Code so vereinfachen, dass nur eine CSV geschrieben wird (ohne Matching-Teil) â€“ dann hast du weniger KomplexitÃ¤t und keine zweite Datei mehr.

Du:
extract_pois_feldkirchen.mjs
Datei
nur eine csv
ChatGPT:

Nachgedacht fÃ¼r ein paar Sekunden
(12.12.2025, 13:25 Uhr)

Alles klar â€” wir werfen die *_matched.csv komplett raus und schreiben nur eine CSV.

In deiner Datei extract_pois_feldkirchen.mjs  musst du dafÃ¼r genau diese Ã„nderungen machen:

1) Diese Konfig-Zeilen lÃ¶schen
LÃ¶sche:

const OUT_BUILDINGS_MATCHED = "./gebaeude_mit_adresse_feldkirchen_matched.csv";
const MAX_MATCH_METERS = 80;
2) Den zweiten CSV-Writer lÃ¶schen
LÃ¶sche den kompletten Block:

const buildingsMatchedWriter = createObjectCsvWriter({
  path: OUT_BUILDINGS_MATCHED,
  header: [
    ...
  ],
});
3) addresses Array lÃ¶schen (wird nicht mehr gebraucht)
LÃ¶sche:

const addresses = []; // fÃ¼r optionales Matching: {lon, lat, label}
und weiter unten im Way-Teil diesen Block ebenfalls lÃ¶schen:

const addrLabel = `${addr.street} ${addr.housenumber}, ${addr.postcode} ${addr.city}`.trim();
addresses.push({ lon: cent.lon, lat: cent.lat, label: addrLabel });
4) Den kompletten Matching-Teil am Ende lÃ¶schen
LÃ¶sche alles ab:

// ==== 6) Optional: Matching ...
bis direkt vor das Ende der run() Funktion.

Damit bleibt nur:

sammeln der buildings

schreiben von OUT_BUILDINGS

Ergebnis
Danach erzeugt das Script nur noch:

âœ… gebaeude_mit_adresse_feldkirchen.csv

und keine zweite Datei mehr.

Wenn du willst, kann ich dir auch die bereinigte Full-Version der Datei am StÃ¼ck posten (statt Patch-Anweisungen).

Du:
bereinigte Full-Version
ChatGPT:

Nachgedacht fÃ¼r ein paar Sekunden
(12.12.2025, 13:30 Uhr)

Hier ist die bereinigte Full-Version von extract_pois_feldkirchen.mjs, die nur eine CSV schreibt und alles â€žmatched/addressesâ€œ entfernt. Basis ist deine aktuelle Datei .

Ergebnis: Es wird nur noch gebaeude_mit_adresse_feldkirchen.csv erzeugt (GebÃ¤ude + Adresse + Lat/Lon).

import fs from "fs";
import * as turf from "@turf/turf";
import { createObjectCsvWriter } from "csv-writer";
import { createOSMStream } from "osm-pbf-parser-node";

// ==== KONFIGURATION ====
// Pfad ggf. anpassen:
const PBF_FILE = "./karnten-latest.osm.pbf";
const BOUNDARY_FILE = "./bezirk_feldkirchen_clean.geojson";

// Output: NUR GebÃ¤ude mit Adresse + Lat/Lon
const OUT_BUILDINGS = "./gebaeude_mit_adresse_feldkirchen.csv";

// ==== 1) Boundary laden ====
const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, "utf8"));
const boundaryFeature =
  boundaryGeojson.type === "FeatureCollection" ? boundaryGeojson.features[0] : boundaryGeojson;

const boundary = turf.feature(boundaryFeature.geometry);

function pointInBezirk(lon, lat) {
  const pt = turf.point([lon, lat]);
  return turf.booleanPointInPolygon(pt, boundary);
}

// ==== 2) CSV Writer ====
const buildingsWriter = createObjectCsvWriter({
  path: OUT_BUILDINGS,
  header: [
    { id: "osm_id", title: "OSM_ID" },
    { id: "osm_type", title: "OSM_TYPE" }, // wird "way"
    { id: "name", title: "NAME" },
    { id: "building", title: "BUILDING" }, // building=*
    { id: "street", title: "ADDR_STRASSE" },
    { id: "housenumber", title: "ADDR_HAUSNUMMER" },
    { id: "postcode", title: "ADDR_PLZ" },
    { id: "city", title: "ADDR_ORT" },
    { id: "lat", title: "LAT" },
    { id: "lon", title: "LON" },
  ],
});

// ==== 3) Tag-Helfer ====
function extractAddress(tags) {
  if (!tags) return null;

  // HARTE BEDINGUNG: Hausnummer muss existieren
  const housenumber = tags["addr:housenumber"] || "";
  if (!housenumber) return null;

  return {
    street: tags["addr:street"] || "",
    housenumber,
    postcode: tags["addr:postcode"] || "",
    city: tags["addr:city"] || tags["addr:place"] || "",
  };
}

// HARTE BEDINGUNG: nur GebÃ¤ude
function isBuilding(tags) {
  return !!(tags && tags["building"]);
}

// ==== 4) PBF Stream: sammeln ====
// WICHTIG: alle Nodes speichern, damit Centroids berechnet werden kÃ¶nnen
const nodeMap = new Map(); // nodeId -> {lat, lon}
const buildings = []; // Ausgabeobjekte

function centroidFromRefs(refs) {
  const coords = [];
  for (const id of refs || []) {
    const n = nodeMap.get(id);
    if (n) coords.push([n.lon, n.lat]);
  }
  if (coords.length < 2) return null;
  const c = turf.centroid(turf.multiPoint(coords)).geometry.coordinates;
  return { lon: c[0], lat: c[1] };
}

async function run() {
  console.log(`[${new Date().toISOString()}] Start GebÃ¤ude-Extraktion (nur building + addr + lat/lon)â€¦`);

  if (!fs.existsSync(PBF_FILE)) {
    console.error("PBF nicht gefunden:", PBF_FILE);
    process.exit(1);
  }

  const stream = createOSMStream(PBF_FILE, { withTags: true, withInfo: false });

  let nodesSeen = 0;
  let waysSeen = 0;

  for await (const e of stream) {
    if (e.type === "node") {
      // Node-Koordinaten immer speichern (damit Centroids berechnet werden kÃ¶nnen)
      if (typeof e.lat === "number" && typeof e.lon === "number") {
        nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
      }

      nodesSeen++;
      if (nodesSeen % 500000 === 0) {
        console.log(`[${new Date().toISOString()}] Nodes: ${nodesSeen} (nodeMap: ${nodeMap.size}) â€¦`);
      }
      continue;
    }

    // NUR GebÃ¤ude-Ways ausgeben
    if (e.type === "way") {
      waysSeen++;

      const tags = e.tags || {};
      if (!isBuilding(tags)) continue;              // HARTE BEDINGUNG 1
      const addr = extractAddress(tags);
      if (!addr) continue;                          // HARTE BEDINGUNG 2 (Adresse)

      const cent = centroidFromRefs(e.refs);
      if (!cent) continue;                          // HARTE BEDINGUNG 3 (lat/lon)
      if (!pointInBezirk(cent.lon, cent.lat)) continue;

      // Alles erfÃ¼llt -> ausgeben
      const name = tags["name"] || "";
      const buildingVal = String(tags["building"]);

      buildings.push({
        osm_id: e.id,
        osm_type: "way",
        name,
        building: buildingVal,
        ...addr,
        lat: cent.lat,
        lon: cent.lon,
      });

      if (waysSeen % 200000 === 0) {
        console.log(`[${new Date().toISOString()}] Ways: ${waysSeen} | Treffer: ${buildings.length}`);
      }
    }
  }

  console.log(`[${new Date().toISOString()}] Fertig gesammelt.`);
  console.log(`  GebÃ¤ude-Treffer (building+addr+latlon): ${buildings.length}`);

  // ==== 5) Haupt-CSV schreiben ====
  await buildingsWriter.writeRecords(
    buildings.map((b) => ({
      osm_id: b.osm_id,
      osm_type: b.osm_type,
      name: b.name,
      building: b.building,
      street: b.street,
      housenumber: b.housenumber,
      postcode: b.postcode,
      city: b.city,
      lat: b.lat,
      lon: b.lon,
    }))
  );

  console.log(`[${new Date().toISOString()}] Output: ${OUT_BUILDINGS}`);
}

run().catch((err) => {
  console.error("Fehler:", err);
  process.exit(1);
});
AusfÃ¼hren wie gehabt:

node extract_pois_feldkirchen.mjs
Wenn du willst, kann ich dir als nÃ¤chsten Schritt noch ein kleines Feature einbauen: Fallback-Name, falls NAME leer ist (z. B. â€žMartin-Luther-StraÃŸe 14â€œ).

Du:
extract_feldkirchen_from_pbf.mjs
Datei
extract_pois_feldkirchen.mjs
Datei
fÃ¼hre die Files zusammen , als ergebnis werden 2 Files erwartet. eines mit den privatadressen und eines wie mit dem inhalt aus extract_pois_feldkirchen.mjs. und keine doppelten eintrÃ¤ge
ChatGPT:

Nachgedacht fÃ¼r 16s
(12.12.2025, 13:45 Uhr)

Alles klar â€” wir machen einen einzigen Lauf Ã¼ber die PBF und schreiben am Ende genau 2 CSV-Dateien:

privatadressen_feldkirchen.csv

gebaeude_mit_adresse_feldkirchen.csv (Inhalt wie dein extract_pois_feldkirchen.mjs) 

Dabei:

nur EintrÃ¤ge mit Adresse + LAT/LON

keine doppelten EintrÃ¤ge

GebÃ¤ude-Liste bleibt â€œbuilding + addr + centroid + im Bezirkâ€ wie in deinem Script 

Privatadressen = Adressen (Nodes oder nicht-building-Ways) im Bezirk, die nicht schon als GebÃ¤ude-Adresse vorkommen und nicht offensichtlich Firma/Einrichtung sind (keine amenity/shop/office/... Tags)

Unten ist die bereinigte zusammengefÃ¼hrte Full-Version als neues Script.

Neues Script: extract_two_files_feldkirchen.mjs
Dieses Script ersetzt beide Workflows (extract_feldkirchen_from_pbf.mjs  + extract_pois_feldkirchen.mjs ) durch einen Lauf.

import fs from "fs";
import * as turf from "@turf/turf";
import { createObjectCsvWriter } from "csv-writer";
import { createOSMStream } from "osm-pbf-parser-node";

// ==== KONFIGURATION ====
const PBF_FILE = "./karnten-latest.osm.pbf";
const BOUNDARY_FILE = "./bezirk_feldkirchen_clean.geojson";

// Output 1: Privatadressen (nur addr + lat/lon, dedupliziert, keine Firmen/Einrichtungen)
const OUT_PRIVATE = "./privatadressen_feldkirchen.csv";

// Output 2: GebÃ¤ude mit Adresse (wie extract_pois_feldkirchen.mjs: building + addr + centroid + lat/lon)
const OUT_BUILDINGS = "./gebaeude_mit_adresse_feldkirchen.csv";

// ==== Boundary laden ====
const boundaryGeojson = JSON.parse(fs.readFileSync(BOUNDARY_FILE, "utf8"));
const boundaryFeature =
  boundaryGeojson.type === "FeatureCollection" ? boundaryGeojson.features[0] : boundaryGeojson;
const boundary = turf.feature(boundaryFeature.geometry);

function pointInBezirk(lon, lat) {
  return turf.booleanPointInPolygon(turf.point([lon, lat]), boundary);
}

// ==== CSV Writer ====
const privateWriter = createObjectCsvWriter({
  path: OUT_PRIVATE,
  header: [
    { id: "street", title: "STRASSE" },
    { id: "housenumber", title: "HAUSNUMMER" },
    { id: "postcode", title: "PLZ" },
    { id: "city", title: "ORT" },
    { id: "lat", title: "LAT" },
    { id: "lon", title: "LON" },
    { id: "source", title: "SOURCE" }, // node|way (nur Info)
    { id: "osm_id", title: "OSM_ID" },
  ],
});

const buildingsWriter = createObjectCsvWriter({
  path: OUT_BUILDINGS,
  header: [
    { id: "osm_id", title: "OSM_ID" },
    { id: "osm_type", title: "OSM_TYPE" }, // "way"
    { id: "name", title: "NAME" },
    { id: "building", title: "BUILDING" },
    { id: "street", title: "ADDR_STRASSE" },
    { id: "housenumber", title: "ADDR_HAUSNUMMER" },
    { id: "postcode", title: "ADDR_PLZ" },
    { id: "city", title: "ADDR_ORT" },
    { id: "lat", title: "LAT" },
    { id: "lon", title: "LON" },
  ],
});

// ==== Helpers ====
function extractAddress(tags) {
  if (!tags) return null;
  const housenumber = tags["addr:housenumber"] || "";
  if (!housenumber) return null;

  return {
    street: (tags["addr:street"] || "").trim(),
    housenumber: String(housenumber).trim(),
    postcode: (tags["addr:postcode"] || "").trim(),
    city: (tags["addr:city"] || tags["addr:place"] || "").trim(),
  };
}

function addrKey(a) {
  // Normalisierte Adresse als Dedupe-Key (GroÃŸ/Klein egal, Leerzeichen normalisieren)
  const norm = (s) => String(s || "").trim().toLowerCase().replace(/\s+/g, " ");
  return [
    norm(a.street),
    norm(a.housenumber),
    norm(a.postcode),
    norm(a.city),
  ].join("|");
}

function isBuilding(tags) {
  return !!(tags && tags["building"]);
}

// Heuristik: â€œFirma/Einrichtungâ€ (fÃ¼r Privatadressen ausschlieÃŸen)
function looksLikePoi(tags) {
  if (!tags) return false;
  // wenn ein Adress-Node/Way gleichzeitig POI ist â†’ nicht privat
  const keys = [
    "amenity",
    "shop",
    "office",
    "craft",
    "tourism",
    "leisure",
    "healthcare",
    "industrial",
    "public_transport",
    "railway",
  ];
  return keys.some((k) => tags[k] != null);
}

function centroidFromRefs(refs, nodeMap) {
  const coords = [];
  for (const id of refs || []) {
    const n = nodeMap.get(id);
    if (n) coords.push([n.lon, n.lat]);
  }
  if (coords.length < 2) return null;
  const c = turf.centroid(turf.multiPoint(coords)).geometry.coordinates;
  return { lon: c[0], lat: c[1] };
}

// ==== Main ====
async function run() {
  console.log(`[${new Date().toISOString()}] Start: 2 Dateien erzeugen (Privatadressen + GebÃ¤ude)â€¦`);

  if (!fs.existsSync(PBF_FILE)) {
    console.error("PBF nicht gefunden:", PBF_FILE);
    process.exit(1);
  }

  const stream = createOSMStream(PBF_FILE, { withTags: true, withInfo: false });

  // FÃ¼r Ways-Centroids: alle Node-Koordinaten speichern (sonst fehlen lat/lon bei GebÃ¤uden)
  const nodeMap = new Map(); // nodeId -> {lat, lon}

  // Ergebnis-Sammlungen
  const buildings = [];
  const privateAddrs = [];

  // Dedupe-Sets
  const seenBuildingsAddr = new Set(); // addrKey, damit Privatadressen keine GebÃ¤ude-Adressen duplizieren
  const seenPrivateAddr = new Set();   // addrKey, damit Privatadressen keine Duplikate bekommen

  let nodesSeen = 0;
  let waysSeen = 0;

  for await (const e of stream) {
    if (e.type === "node") {
      // Node coords immer speichern
      if (typeof e.lat === "number" && typeof e.lon === "number") {
        nodeMap.set(e.id, { lat: e.lat, lon: e.lon });
      }

      // Privatadresse kann auch als reiner Adress-Node existieren (addr:* ohne building)
      const addr = extractAddress(e.tags);
      if (addr && typeof e.lat === "number" && typeof e.lon === "number") {
        if (pointInBezirk(e.lon, e.lat)) {
          // Nur privat, wenn nicht gleichzeitig POI/Firma/Einrichtung
          if (!looksLikePoi(e.tags)) {
            const k = addrKey(addr);
            // Privat nur, wenn nicht schon durch GebÃ¤ude belegt (kommt spÃ¤ter auch noch, aber wir filtern final nach buildings)
            if (!seenPrivateAddr.has(k)) {
              privateAddrs.push({
                ...addr,
                lat: e.lat,
                lon: e.lon,
                source: "node",
                osm_id: e.id,
                _key: k,
              });
              seenPrivateAddr.add(k);
            }
          }
        }
      }

      nodesSeen++;
      if (nodesSeen % 500000 === 0) {
        console.log(`[${new Date().toISOString()}] Nodes: ${nodesSeen} (nodeMap: ${nodeMap.size}) â€¦`);
      }
      continue;
    }

    if (e.type === "way") {
      waysSeen++;
      const tags = e.tags || {};
      const addr = extractAddress(tags);

      // A) GebÃ¤ude-Ausgabe (wie extract_pois_feldkirchen.mjs)
      if (addr && isBuilding(tags)) {
        const cent = centroidFromRefs(e.refs, nodeMap);
        if (cent && typeof cent.lat === "number" && typeof cent.lon === "number" && pointInBezirk(cent.lon, cent.lat)) {
          const k = addrKey(addr);
          // Dedupe GebÃ¤ude nach Adresse (keine Doppelten)
          if (!seenBuildingsAddr.has(k)) {
            seenBuildingsAddr.add(k);
            buildings.push({
              osm_id: e.id,
              osm_type: "way",
              name: tags["name"] || "",
              building: String(tags["building"]),
              ...addr,
              lat: cent.lat,
              lon: cent.lon,
            });
          }
        }
        continue;
      }

      // B) Privatadresse als Way ohne building (selten, aber mÃ¶glich: addr:* auf FlÃ¤chen, GrundstÃ¼cke, etc.)
      if (addr && !isBuilding(tags)) {
        // Nur wenn wir Koordinaten ableiten kÃ¶nnen
        const cent = centroidFromRefs(e.refs, nodeMap);
        if (cent && typeof cent.lat === "number" && typeof cent.lon === "number" && pointInBezirk(cent.lon, cent.lat)) {
          // Nur privat, wenn nicht gleichzeitig POI/Firma/Einrichtung
          if (!looksLikePoi(tags)) {
            const k = addrKey(addr);
            if (!seenPrivateAddr.has(k)) {
              privateAddrs.push({
                ...addr,
                lat: cent.lat,
                lon: cent.lon,
                source: "way",
                osm_id: e.id,
                _key: k,
              });
              seenPrivateAddr.add(k);
            }
          }
        }
      }

      if (waysSeen % 200000 === 0) {
        console.log(
          `[${new Date().toISOString()}] Ways: ${waysSeen} | GebÃ¤ude: ${buildings.length} | Privat: ${privateAddrs.length}`
        );
      }
    }
  }

  // Finaler Privat-Filter: Alles entfernen, was eine GebÃ¤ude-Adresse dupliziert
  const privateFinal = privateAddrs.filter((p) => !seenBuildingsAddr.has(p._key));

  // Output schreiben
  await buildingsWriter.writeRecords(buildings);
  await privateWriter.writeRecords(
    privateFinal.map(({ _key, ...rest }) => rest)
  );

  console.log(`[${new Date().toISOString()}] Fertig.`);
  console.log(`  GebÃ¤ude (dedupliziert):        ${buildings.length} -> ${OUT_BUILDINGS}`);
  console.log(`  Privatadressen (dedupliziert): ${privateFinal.length} -> ${OUT_PRIVATE}`);
}

run().catch((err) => {
  console.error("Fehler:", err);
  process.exit(1);
});
AusfÃ¼hren
node extract_two_files_feldkirchen.mjs
Du bekommst dann genau 2 Dateien:

gebaeude_mit_adresse_feldkirchen.csv (wie bisher, ohne Duplikate) 

privatadressen_feldkirchen.csv (Adresse+Lat/Lon, ohne Duplikate, ohne GebÃ¤ude-Adressen)

Hinweis zur â€œPrivatâ€-Definition
OSM kennt kein offizielles Tag â€žprivatâ€œ. Deshalb ist â€œPrivatadressenâ€ hier pragmatisch definiert als:

Adress-Objekte, die nicht bereits als building=*-GebÃ¤udeadresse im GebÃ¤ude-File vorkommen

und keine typischen POI-Tags tragen (amenity/shop/office/...)

Wenn du â€œPrivatâ€ enger fassen willst (z. B. nur building in {house,residential,apartments}), sagâ€™s kurz â€“ dann setze ich dir den Filter exakt so.
