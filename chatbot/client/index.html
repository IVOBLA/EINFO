<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>EINFO - Stabsarbeit Simulator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, sans-serif; background: #0f172a; color: #e2e8f0; min-height: 100vh; }

    /* Header */
    .header {
      background: #1e293b;
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #334155;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .header h1 { font-size: 1.1rem; }
    .header-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.8rem;
      font-weight: 500;
    }
    .status-badge.active { background: #22c55e; color: #000; }
    .status-badge.inactive { background: #64748b; }
    .status-badge.paused { background: #f59e0b; color: #000; }
    .status-badge.scenario { background: #3b82f6; }

    .connected { color: #22c55e; font-size: 0.85rem; }
    .disconnected { color: #ef4444; font-size: 0.85rem; }

    /* Main Grid */
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
      padding: 1rem;
      max-height: calc(100vh - 60px);
    }

    @media (max-width: 1400px) {
      .main-grid { grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 900px) {
      .main-grid { grid-template-columns: 1fr; max-height: none; }
    }

    /* Cards */
    .card {
      background: #1e293b;
      border-radius: 0.75rem;
      padding: 1rem;
      border: 1px solid #334155;
      display: flex;
      flex-direction: column;
      max-height: 400px;
      overflow: hidden;
    }
    .card.tall { max-height: 500px; }
    .card h2 {
      font-size: 0.85rem;
      color: #94a3b8;
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      flex-shrink: 0;
    }

    /* Scrollable content */
    .scrollable {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    /* Stats */
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
    }
    .stat-item {
      background: #0f172a;
      padding: 0.5rem;
      border-radius: 0.5rem;
      text-align: center;
    }
    .stat-value { font-size: 1.25rem; font-weight: 700; color: #38bdf8; }
    .stat-label { font-size: 0.65rem; color: #64748b; margin-top: 0.125rem; }

    /* Role list */
    .role-list { list-style: none; }
    .role-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.375rem 0.5rem;
      border-radius: 0.375rem;
      margin-bottom: 0.25rem;
      font-size: 0.85rem;
    }
    .role-item.active { background: rgba(34, 197, 94, 0.1); }
    .role-item.missing { background: rgba(239, 68, 68, 0.1); }
    .role-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
      display: inline-block;
    }
    .role-dot.active { background: #22c55e; }
    .role-dot.missing { background: #ef4444; }

    /* Event log */
    .event-log { font-family: monospace; font-size: 0.75rem; }
    .event-item {
      padding: 0.25rem 0.5rem;
      border-bottom: 1px solid #334155;
    }
    .event-time { color: #64748b; margin-right: 0.5rem; }
    .event-category {
      padding: 0.1rem 0.3rem;
      border-radius: 0.25rem;
      font-size: 0.6rem;
      margin-right: 0.5rem;
    }
    .event-category.simulation { background: #3b82f6; }
    .event-category.llm { background: #8b5cf6; }
    .event-category.user { background: #22c55e; }
    .event-category.exercise { background: #f59e0b; }
    .event-category.error { background: #ef4444; }

    .request-log { font-family: monospace; font-size: 0.75rem; }
    .request-item {
      padding: 0.35rem 0.5rem;
      border-bottom: 1px solid #334155;
      cursor: pointer;
      transition: background 0.2s;
    }
    .request-item:hover { background: #1e3a5f; }
    .request-meta { color: #94a3b8; font-size: 0.65rem; margin-top: 0.15rem; }

    /* Buttons */
    .btn {
      padding: 0.4rem 0.8rem;
      border-radius: 0.5rem;
      border: none;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.15s;
    }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-success { background: #22c55e; color: white; }
    .btn-success:hover { background: #16a34a; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-danger:hover { background: #dc2626; }
    .btn-secondary { background: #475569; color: white; }
    .btn-secondary:hover { background: #334155; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn-group { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.75rem; }

    /* Form elements */
    input[type="text"], textarea, select {
      width: 100%;
      padding: 0.4rem 0.6rem;
      border-radius: 0.5rem;
      border: 1px solid #475569;
      background: #0f172a;
      color: #e2e8f0;
      font-size: 0.85rem;
    }
    input[type="text"]:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #3b82f6;
    }
    textarea { min-height: 80px; resize: vertical; }

    /* Chat */
    .chat-input-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    .chat-input-row input { flex: 1; }
    .chat-log {
      font-family: monospace;
      font-size: 0.8rem;
      white-space: pre-wrap;
      background: #0f172a;
      padding: 0.5rem;
      border-radius: 0.5rem;
    }

    /* GPU Status */
    .gpu-badge {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
      border-radius: 0.375rem;
      background: #ecfdf3;
      color: #166534;
    }
    .gpu-badge.unavailable { background: #fef2f2; color: #991b1b; }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-overlay.hidden { display: none; }
    .modal {
      background: #1e293b;
      border-radius: 1rem;
      padding: 1.5rem;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid #334155;
    }
    .modal h2 { font-size: 1.25rem; margin-bottom: 1rem; color: #f1f5f9; }

    /* Scenario cards */
    .scenario-list { display: flex; flex-direction: column; gap: 0.75rem; }
    .scenario-card {
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 0.75rem;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.15s;
    }
    .scenario-card:hover { border-color: #3b82f6; background: #1e293b; }
    .scenario-card.selected { border-color: #22c55e; background: #1e293b; }
    .scenario-card h3 { font-size: 1rem; margin-bottom: 0.25rem; color: #f1f5f9; }
    .scenario-card p { font-size: 0.85rem; color: #94a3b8; margin-bottom: 0.5rem; }
    .scenario-meta {
      display: flex;
      gap: 0.75rem;
      font-size: 0.75rem;
      color: #64748b;
    }
    .scenario-meta span {
      background: #334155;
      padding: 0.125rem 0.5rem;
      border-radius: 0.25rem;
    }

    /* Sim Log */
    .sim-log {
      background: #0f172a;
      padding: 0.5rem;
      border-radius: 0.5rem;
      font-family: monospace;
      font-size: 0.75rem;
      white-space: pre-wrap;
    }

    /* Operations output */
    .ops-output {
      background: #0f172a;
      padding: 0.5rem;
      border-radius: 0.5rem;
      font-family: monospace;
      font-size: 0.7rem;
      white-space: pre-wrap;
      overflow-x: auto;
    }

    small { color: #64748b; font-size: 0.75rem; }
    .error-text { color: #ef4444; font-size: 0.8rem; }

    /* KI-Aktionen Liste */
    .action-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .action-item {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0.75rem;
      background: #0f172a;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .action-item:hover { background: #1e3a5f; }
    .action-badge {
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.7rem;
      font-weight: 500;
      white-space: nowrap;
    }
    .action-badge.protokoll { background: #1e40af; color: #93c5fd; }
    .action-badge.aufgabe { background: #166534; color: #86efac; }
    .action-badge.einsatz { background: #991b1b; color: #fca5a5; }
    .action-content { flex: 1; min-width: 0; }
    .action-title {
      font-size: 0.8rem;
      color: #e2e8f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .action-time { font-size: 0.7rem; color: #64748b; margin-top: 0.25rem; }
    .action-arrow { color: #64748b; font-size: 0.8rem; }

    /* Filter Buttons */
    .filter-group {
      display: flex;
      gap: 0.375rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }
    .action-category-btn,
    .action-mode-btn {
      padding: 0.25rem 0.5rem;
      border-radius: 0.375rem;
      border: none;
      font-size: 0.7rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .action-category-btn.all { background: #475569; color: #e2e8f0; }
    .action-category-btn.all.active { background: #64748b; }
    .action-category-btn.protokoll { background: #1e3a5f; color: #93c5fd; }
    .action-category-btn.protokoll.active { background: #1e40af; }
    .action-category-btn.aufgabe { background: #14532d; color: #86efac; }
    .action-category-btn.aufgabe.active { background: #166534; }
    .action-category-btn.einsatz { background: #450a0a; color: #fca5a5; }
    .action-category-btn.einsatz.active { background: #991b1b; }
    .action-mode-btn { background: #334155; color: #e2e8f0; }
    .action-mode-btn.active { background: #475569; }

    /* Action Modal */
    .action-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }
    .action-modal-overlay.hidden { display: none; }
    .action-modal-content {
      background: #1e293b;
      border-radius: 0.75rem;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow: hidden;
      border: 1px solid #334155;
    }
    .action-modal-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    .action-modal-header h3 { font-size: 1rem; color: #f8fafc; margin-bottom: 0.25rem; }
    .action-modal-header .modal-time { font-size: 0.8rem; color: #94a3b8; }
    .action-modal-close {
      background: none;
      border: none;
      color: #94a3b8;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }
    .action-modal-close:hover { color: #e2e8f0; }
    .action-modal-body {
      padding: 1.5rem;
      overflow-y: auto;
      max-height: 60vh;
    }
    .modal-field { margin-bottom: 1rem; }
    .modal-field label {
      display: block;
      font-size: 0.7rem;
      color: #94a3b8;
      margin-bottom: 0.25rem;
      text-transform: uppercase;
    }
    .modal-field p { color: #e2e8f0; white-space: pre-wrap; word-break: break-word; font-size: 0.85rem; }
    .modal-field pre {
      background: #0f172a;
      padding: 0.75rem;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      overflow-x: auto;
      color: #e2e8f0;
    }
    .action-modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid #334155;
      text-align: right;
    }
    .empty-state {
      text-align: center;
      padding: 1.5rem;
      color: #64748b;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>EINFO Stabsarbeit Simulator</h1>
    <div class="header-right">
      <span id="scenario-badge" class="status-badge scenario" style="display:none;"></span>
      <span id="sse-status" class="disconnected">Nicht verbunden</span>
      <span id="exercise-status" class="status-badge inactive">Keine Simulation aktiv</span>
    </div>
  </header>

  <main class="main-grid">
    <!-- Steuerung -->
    <section class="card">
      <h2>Steuerung</h2>
      <div id="control-info">
        <p style="color: #64748b; font-size: 0.85rem;">Starten Sie eine Simulation mit Szenario-Auswahl</p>
      </div>
      <div class="btn-group">
        <button id="btn-start" class="btn btn-success">Simulation starten</button>
        <button id="btn-step" class="btn btn-primary" disabled>Schritt</button>
        <button id="btn-pause" class="btn btn-secondary" disabled>Pause</button>
        <button id="btn-end" class="btn btn-danger" disabled>Beenden</button>
      </div>
      <div class="scrollable" style="margin-top: 0.75rem;">
        <div id="sim-log" class="sim-log"></div>
      </div>
    </section>

    <!-- Live-Statistiken -->
    <section class="card">
      <h2>Live-Statistiken</h2>
      <div class="stat-grid">
        <div class="stat-item">
          <div class="stat-value" id="stat-steps">0</div>
          <div class="stat-label">Sim-Schritte</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-llm">0</div>
          <div class="stat-label">LLM-Aufrufe</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-protocols">0</div>
          <div class="stat-label">Protokolle</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-tasks">0</div>
          <div class="stat-label">Aufgaben</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-incidents">0</div>
          <div class="stat-label">Einsatzstellen</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-duration">0:00</div>
          <div class="stat-label">Dauer</div>
        </div>
        <div class="stat-item" id="stat-remaining-container" style="display: none;">
          <div class="stat-value" id="stat-remaining">--:--</div>
          <div class="stat-label">Restzeit</div>
        </div>
        <div class="stat-item" id="stat-waiting-container" style="display: none;">
          <div class="stat-value" id="stat-waiting" style="color: #f59e0b;">⏸</div>
          <div class="stat-label">Wartet auf Rollen</div>
        </div>
      </div>

      <h2 style="margin-top: 1rem;">Rollen-Status</h2>
      <div class="scrollable">
        <ul class="role-list" id="role-list">
          <li class="role-item missing"><span><span class="role-dot missing"></span>Lade...</span></li>
        </ul>
      </div>
    </section>

    <!-- Event-Log -->
    <section class="card tall">
      <h2>Event-Log (Live)</h2>
      <div class="scrollable event-log" id="event-log">
        <div class="event-item" style="color: #64748b;">Warte auf Events...</div>
      </div>
    </section>

    <!-- LLM Requests -->
    <section class="card tall">
      <h2>LLM Requests</h2>
      <div class="scrollable request-log" id="llm-request-log">
        <div class="request-item" style="color: #64748b;">Noch keine LLM Requests.</div>
      </div>
    </section>

    <!-- Chat -->
    <section class="card tall">
      <h2>Chat (nur bei Pause)</h2>
      <div class="scrollable">
        <div id="chat-log" class="chat-log"></div>
      </div>
      <div class="chat-input-row">
        <input id="chat-input" type="text" placeholder="Frage an den EINFO-Chatbot..." />
        <button id="chat-send" class="btn btn-primary">Senden</button>
      </div>
    </section>

    <!-- Operations Output -->
    <section class="card tall">
      <h2>Operations (LLM-Ausgabe)</h2>
      <div class="scrollable">
        <div id="ops-output" class="ops-output"></div>
      </div>
    </section>

    <!-- KI-Aktionen -->
    <section class="card tall">
      <h2 style="display: flex; justify-content: space-between; align-items: center;">
        KI-Aktionen
        <button id="btn-refresh-actions" class="btn btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.7rem;">
          Aktualisieren
        </button>
      </h2>
      <div class="filter-group">
        <button class="action-category-btn all active" data-filter="">Alle</button>
        <button class="action-category-btn protokoll" data-filter="protokoll">Protokoll</button>
        <button class="action-category-btn aufgabe" data-filter="aufgabe">Aufgaben</button>
        <button class="action-category-btn einsatz" data-filter="einsatz">Einsaetze</button>
      </div>
      <div class="filter-group">
        <button class="action-mode-btn active" data-mode="applied">Angewandt</button>
        <button class="action-mode-btn" data-mode="rejected">Verworfen</button>
      </div>
      <div class="scrollable">
        <div id="action-list" class="action-list">
          <div class="empty-state">Lade KI-Aktionen...</div>
        </div>
      </div>
    </section>

    <!-- LLM-Test -->
    <section class="card tall">
      <h2>LLM-Test</h2>
      <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
        <select id="llm-model-select" style="flex: 1;"></select>
        <button id="llm-refresh" class="btn btn-secondary">Neu laden</button>
      </div>
      <small>Test-Prompt eingeben:</small>
      <textarea id="llm-prompt" placeholder="Beispiel: Fasse die aktuellen Einsatzstellen zusammen..." style="margin-top: 0.25rem;"></textarea>
      <div class="btn-group">
        <button id="llm-send" class="btn btn-primary">Testen</button>
        <span id="llm-gpu-status" class="gpu-badge">GPU: keine Daten</span>
      </div>
      <span id="llm-error" class="error-text"></span>
      <div class="scrollable" style="margin-top: 0.5rem;">
        <div id="llm-output" class="sim-log"></div>
      </div>
    </section>
  </main>

  <!-- Szenario-Auswahl Modal -->
  <div id="scenario-modal" class="modal-overlay hidden">
    <div class="modal">
      <h2>Szenario auswaehlen</h2>
      <p style="color: #94a3b8; margin-bottom: 1rem; font-size: 0.9rem;">
        Waehlen Sie ein Uebungsszenario aus oder starten Sie ohne Szenario (freier Modus).
      </p>
      <div id="scenario-list" class="scenario-list">
        <p style="color: #64748b;">Szenarien werden geladen...</p>
      </div>
      <div class="btn-group" style="margin-top: 1.5rem; justify-content: flex-end;">
        <button id="btn-start-free" class="btn btn-secondary">Ohne Szenario starten</button>
        <button id="btn-start-scenario" class="btn btn-success" disabled>Mit Szenario starten</button>
        <button id="btn-cancel-modal" class="btn btn-secondary">Abbrechen</button>
      </div>
    </div>
  </div>

  <!-- KI-Aktionen Detail Modal -->
  <div id="action-modal" class="action-modal-overlay hidden">
    <div class="action-modal-content">
      <div class="action-modal-header">
        <div>
          <h3 id="action-modal-title">Aktion Details</h3>
          <div class="modal-time" id="action-modal-time"></div>
        </div>
        <button class="action-modal-close" id="action-modal-close">&times;</button>
      </div>
      <div class="action-modal-body" id="action-modal-body">
        <!-- Content wird dynamisch eingefuegt -->
      </div>
      <div class="action-modal-footer">
        <button class="btn btn-secondary" id="action-modal-close-btn">Schliessen</button>
      </div>
    </div>
  </div>

  <script type="module">
    // ============================================================
    // State
    // ============================================================
    let simulationRunning = false;
    let simulationPaused = false;
    let exerciseId = null;
    let statistics = { simSteps: 0, llmCalls: 0, protocolsCreated: 0, tasksCreated: 0, incidentsCreated: 0 };
    let eventSource = null;
    let startTime = null;
    let durationInterval = null;
    let selectedScenarioId = null;
    let activeScenario = null;
    let llmRequestEvents = [];
    let llmRequestView = [];
    const chatEntries = [];
    const BOT_NAME = "Florian";

    // ============================================================
    // DOM Elements
    // ============================================================
    const sseStatus = document.getElementById("sse-status");
    const exerciseStatus = document.getElementById("exercise-status");
    const scenarioBadge = document.getElementById("scenario-badge");
    const controlInfo = document.getElementById("control-info");
    const btnStart = document.getElementById("btn-start");
    const btnStep = document.getElementById("btn-step");
    const btnPause = document.getElementById("btn-pause");
    const btnEnd = document.getElementById("btn-end");
    const simLog = document.getElementById("sim-log");
    const eventLog = document.getElementById("event-log");
    const llmRequestLog = document.getElementById("llm-request-log");
    const roleList = document.getElementById("role-list");
    const opsOutput = document.getElementById("ops-output");

    // Stats
    const statSteps = document.getElementById("stat-steps");
    const statLlm = document.getElementById("stat-llm");
    const statProtocols = document.getElementById("stat-protocols");
    const statTasks = document.getElementById("stat-tasks");
    const statIncidents = document.getElementById("stat-incidents");
    const statDuration = document.getElementById("stat-duration");
    const statRemainingContainer = document.getElementById("stat-remaining-container");
    const statRemaining = document.getElementById("stat-remaining");
    const statWaitingContainer = document.getElementById("stat-waiting-container");

    // Zusätzlicher State für Simulation
    let timeRemaining = null; // Restzeit in Minuten (aus Szenario)
    let durationMinutes = null; // Gesamtdauer des Szenarios
    let waitingForRoles = false; // Ob Simulation auf Rollen wartet
    let totalPausedMs = 0; // Gesamte pausierte Zeit in ms (vom Server)

    // Chat
    const chatInput = document.getElementById("chat-input");
    const chatSend = document.getElementById("chat-send");
    const chatLog = document.getElementById("chat-log");

    // LLM Test
    const llmModelSelect = document.getElementById("llm-model-select");
    const llmPrompt = document.getElementById("llm-prompt");
    const llmSend = document.getElementById("llm-send");
    const llmOutput = document.getElementById("llm-output");
    const llmRefresh = document.getElementById("llm-refresh");
    const llmGpuStatus = document.getElementById("llm-gpu-status");
    const llmError = document.getElementById("llm-error");

    // Modal
    const scenarioModal = document.getElementById("scenario-modal");
    const scenarioList = document.getElementById("scenario-list");
    const btnStartFree = document.getElementById("btn-start-free");
    const btnStartScenario = document.getElementById("btn-start-scenario");
    const btnCancelModal = document.getElementById("btn-cancel-modal");

    // ============================================================
    // SSE Connection
    // ============================================================
    function connectSSE() {
      if (eventSource) eventSource.close();

      eventSource = new EventSource("/api/events");

      eventSource.onopen = () => {
        sseStatus.textContent = "Verbunden";
        sseStatus.className = "connected";
      };

      eventSource.onerror = () => {
        sseStatus.textContent = "Nicht verbunden";
        sseStatus.className = "disconnected";
        setTimeout(connectSSE, 5000);
      };

      eventSource.addEventListener("status", (e) => {
        const data = JSON.parse(e.data);
        if (data.statistics) {
          statistics = { ...statistics, ...data.statistics };
          updateStats();
        }
      });

      eventSource.addEventListener("exercise_started", (e) => {
        const data = JSON.parse(e.data);
        exerciseId = data.exerciseId;
        addEventToLog("exercise", "Uebung gestartet: " + (data.exerciseName || exerciseId));
      });

      eventSource.addEventListener("exercise_ended", (e) => {
        addEventToLog("exercise", "Uebung beendet");
      });

      eventSource.addEventListener("scenario_loaded", (e) => {
        const data = JSON.parse(e.data);
        addEventToLog("simulation", "Szenario geladen: " + data.title);
      });

      eventSource.addEventListener("statistics_update", (e) => {
        const data = JSON.parse(e.data);
        if (data.statistics) {
          statistics = { ...statistics, ...data.statistics };
          updateStats();
        }
      });

      eventSource.addEventListener("audit_event", (e) => {
        const event = JSON.parse(e.data);
        handleAuditEvent(event);
      });

      eventSource.addEventListener("roles_status_changed", (e) => {
        const data = JSON.parse(e.data);
        waitingForRoles = !!data.waitingForRoles;
        totalPausedMs = data.totalPausedMs || 0;

        if (waitingForRoles) {
          addEventToLog("simulation", "Wartet auf aktive Rollen – Zeit pausiert");
          stopDurationTimer();
        } else {
          addEventToLog("simulation", "Rollen wieder aktiv – Simulation fortgesetzt");
          startDurationTimer();
        }

        updateStats();
      });

      eventSource.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          if (data.category) {
            addEventToLog(data.category, data.action || "event");
          }
          if (data.statistics) {
            statistics = { ...statistics, ...data.statistics };
            updateStats();
          }
        } catch {}
      };
    }

    // ============================================================
    // Scenario Modal
    // ============================================================
    async function loadScenarios() {
      try {
        const res = await fetch("/api/scenarios");
        const data = await res.json();

        if (!data.ok || !data.scenarios?.length) {
          scenarioList.innerHTML = '<p style="color: #64748b;">Keine Szenarien gefunden.</p>';
          return;
        }

        scenarioList.innerHTML = data.scenarios.map(s => `
          <div class="scenario-card" data-id="${s.id}">
            <h3>${s.title}</h3>
            <p>${s.description}</p>
            <div class="scenario-meta">
              <span>${s.event_type}</span>
              <span>${s.difficulty}</span>
              <span>${s.duration_minutes} Min.</span>
              <span>${s.mode}</span>
            </div>
          </div>
        `).join("");

        // Click handler for scenario cards
        scenarioList.querySelectorAll(".scenario-card").forEach(card => {
          card.addEventListener("click", () => {
            scenarioList.querySelectorAll(".scenario-card").forEach(c => c.classList.remove("selected"));
            card.classList.add("selected");
            selectedScenarioId = card.dataset.id;
            btnStartScenario.disabled = false;
          });
        });
      } catch (err) {
        scenarioList.innerHTML = '<p style="color: #ef4444;">Fehler beim Laden der Szenarien.</p>';
      }
    }

    function showScenarioModal() {
      selectedScenarioId = null;
      btnStartScenario.disabled = true;
      scenarioModal.classList.remove("hidden");
      loadScenarios();
    }

    function hideScenarioModal() {
      scenarioModal.classList.add("hidden");
    }

    // ============================================================
    // Simulation Control
    // ============================================================
    async function startSimulation(scenarioId = null) {
      const resumeRequested = simulationPaused && !scenarioId;
      appendSimLog(resumeRequested ? "Simulation wird fortgesetzt..." : "Simulation wird gestartet...");
      setBusy(true);

      try {
        const body = scenarioId ? { scenarioId } : resumeRequested ? { resume: true } : {};
        const res = await fetch("/api/sim/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const data = await res.json();

        if (data.ok) {
          simulationRunning = true;
          simulationPaused = false;
          // Verwende startTime vom Server, falls vorhanden
          if (data.startTime) {
            startTime = data.startTime;
          } else if (!resumeRequested || !startTime) {
            startTime = Date.now();
          }
          startDurationTimer();

          if (data.scenario) {
            activeScenario = data.scenario;
            scenarioBadge.textContent = data.scenario.title;
            scenarioBadge.style.display = "inline";
            controlInfo.innerHTML = `<p><strong>${data.scenario.title}</strong></p>`;
          } else {
            controlInfo.innerHTML = `<p><strong>Freier Modus</strong></p>`;
          }

          appendSimLog(resumeRequested ? "Simulation fortgesetzt." : "Simulation gestartet.");
          addEventToLog(
            "simulation",
            resumeRequested
              ? "Simulation fortgesetzt"
              : "Simulation gestartet" + (data.scenario ? `: ${data.scenario.title}` : "")
          );
          updateUI();
        } else {
          appendSimLog("Fehler: " + (data.error || "Unbekannt"));
        }
      } catch (err) {
        appendSimLog("Fehler: " + err);
      } finally {
        setBusy(false);
      }
    }

    async function stepSimulation() {
      appendSimLog("Manueller Schritt...");
      setBusy(true);

      try {
        const res = await fetch("/api/sim/step", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ source: "manual" })
        });
        const data = await res.json();

        if (data.ok) {
          appendSimLog("Schritt OK - Operations empfangen.");
          statistics.simSteps = (statistics.simSteps || 0) + 1;
          statistics.llmCalls = (statistics.llmCalls || 0) + 1;
          if (data.operations?.protokoll?.create?.length) {
            statistics.protocolsCreated = (statistics.protocolsCreated || 0) + data.operations.protokoll.create.length;
          }
          if (data.operations?.aufgaben?.create?.length) {
            statistics.tasksCreated = (statistics.tasksCreated || 0) + data.operations.aufgaben.create.length;
          }
          if (data.operations?.board?.createIncidentSites?.length) {
            statistics.incidentsCreated = (statistics.incidentsCreated || 0) + data.operations.board.createIncidentSites.length;
          }
          updateStats();
          opsOutput.textContent = JSON.stringify({ operations: data.operations, analysis: data.analysis }, null, 2);
          addEventToLog("llm", "Operations generiert");
        } else {
          appendSimLog("Fehler: " + (data.error || data.reason));
        }
      } catch (err) {
        appendSimLog("Fehler: " + err);
      } finally {
        setBusy(false);
      }
    }

    async function pauseSimulation() {
      appendSimLog("Simulation wird pausiert...");
      try {
        await fetch("/api/sim/pause", { method: "POST" });
        simulationRunning = false;
        simulationPaused = true;
        appendSimLog("Simulation pausiert. Chat verfuegbar.");
        addEventToLog("simulation", "Simulation pausiert");
        updateUI();
      } catch (err) {
        appendSimLog("Fehler: " + err);
      }
    }

    async function togglePauseResume() {
      if (simulationPaused) {
        await startSimulation(null);
        return;
      }
      await pauseSimulation();
    }

    async function endSimulation() {
      if (!confirm("Simulation wirklich beenden?")) return;

      try {
        await fetch("/api/sim/pause", { method: "POST" });
        await fetch("/api/audit/end", { method: "POST" });
        simulationRunning = false;
        simulationPaused = false;
        stopDurationTimer();
        activeScenario = null;
        scenarioBadge.style.display = "none";
        controlInfo.innerHTML = '<p style="color: #64748b;">Starten Sie eine Simulation mit Szenario-Auswahl</p>';
        appendSimLog("Simulation beendet.");
        addEventToLog("exercise", "Simulation beendet");
        updateUI();
      } catch (err) {
        appendSimLog("Fehler: " + err);
      }
    }

    // ============================================================
    // UI Helpers
    // ============================================================
    function updateUI() {
      if (simulationRunning) {
        exerciseStatus.textContent = "Simulation aktiv";
        exerciseStatus.className = "status-badge active";
        btnStart.disabled = true;
        btnStep.disabled = false;
        btnPause.disabled = false;
        btnPause.textContent = "Pause";
        btnEnd.disabled = false;
      } else if (simulationPaused) {
        exerciseStatus.textContent = "Simulation pausiert";
        exerciseStatus.className = "status-badge paused";
        btnStart.disabled = true;
        btnStep.disabled = false;
        btnPause.disabled = false;
        btnPause.textContent = "Fortsetzen";
        btnEnd.disabled = false;
      } else {
        exerciseStatus.textContent = "Keine Simulation aktiv";
        exerciseStatus.className = "status-badge inactive";
        btnStart.disabled = false;
        btnStep.disabled = true;
        btnPause.disabled = true;
        btnPause.textContent = "Pause";
        btnEnd.disabled = true;
      }
    }

    function updateStats() {
      statSteps.textContent = statistics.simSteps || 0;
      statLlm.textContent = statistics.llmCalls || 0;
      statProtocols.textContent = statistics.protocolsCreated || 0;
      statTasks.textContent = statistics.tasksCreated || 0;
      statIncidents.textContent = statistics.incidentsCreated || 0;

      // Restzeit anzeigen wenn Szenario mit Zeitlimit aktiv ist
      if (timeRemaining !== null && durationMinutes !== null) {
        statRemainingContainer.style.display = "";
        statRemaining.textContent = formatMinutes(timeRemaining);
        // Farbkodierung: rot wenn < 10 Minuten, orange wenn < 30 Minuten
        if (timeRemaining < 10) {
          statRemaining.style.color = "#ef4444";
        } else if (timeRemaining < 30) {
          statRemaining.style.color = "#f59e0b";
        } else {
          statRemaining.style.color = "#38bdf8";
        }
      } else {
        statRemainingContainer.style.display = "none";
      }

      // Wartet-auf-Rollen Status anzeigen
      if (waitingForRoles) {
        statWaitingContainer.style.display = "";
      } else {
        statWaitingContainer.style.display = "none";
      }
    }

    function formatMinutes(minutes) {
      if (minutes === null || minutes === undefined) return "--:--";
      const h = Math.floor(minutes / 60);
      const m = Math.round(minutes % 60);
      if (h > 0) {
        return `${h}:${m.toString().padStart(2, "0")}h`;
      }
      return `${m} Min`;
    }

    function appendSimLog(line) {
      const ts = new Date().toLocaleTimeString();
      simLog.textContent = `[${ts}] ${line}\n` + simLog.textContent;
    }

    function addEventToLog(category, message) {
      const time = new Date().toLocaleTimeString("de-DE");
      const item = document.createElement("div");
      item.className = "event-item";
      item.innerHTML = `
        <span class="event-time">${time}</span>
        <span class="event-category ${category}">${category}</span>
        ${message}
      `;

      const placeholder = eventLog.querySelector('[style*="color: #64748b"]');
      if (placeholder) placeholder.remove();

      eventLog.insertBefore(item, eventLog.firstChild);

      while (eventLog.children.length > 100) {
        eventLog.removeChild(eventLog.lastChild);
      }
    }

    function formatDuration(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, "0")}`;
    }

    function formatEventMessage(event) {
      if (!event) return "Event";
      const action = event.action || "event";
      const data = event.data || {};

      if (event.category === "exercise") {
        if (action === "start") return "Uebung gestartet";
        if (action === "end") return "Uebung beendet";
        if (action === "pause") return "Uebung pausiert";
        if (action === "resume") return "Uebung fortgesetzt";
      }

      if (event.category === "simulation") {
        if (action === "step_start") return "Simulationsschritt gestartet";
        if (action === "step_complete") return "Simulationsschritt abgeschlossen";
        if (action === "response_needed") return `Antworten erforderlich (${data.messageCount || 0})`;
        if (action === "open_questions_found") return `Offene Rueckfragen (${data.questionCount || 0})`;
        if (action === "step_skipped_analysis") return "Schritt uebersprungen (Analyse aktiv)";
      }

      if (event.category === "llm") {
        if (action === "ops_call") {
          const duration = typeof data.durationMs === "number" ? ` (${Math.round(data.durationMs)} ms)` : "";
          const modelInfo = data.model ? ` ${data.model}` : "";
          return `LLM-Aufruf${modelInfo}${duration}`;
        }
        if (action === "request") {
          const duration = typeof data.durationMs === "number" ? ` (${Math.round(data.durationMs)} ms)` : "";
          const modelInfo = data.model ? ` ${data.model}` : "";
          const sourceInfo = data.source ? ` – ${data.source}` : "";
          return `LLM-Request${modelInfo}${duration}${sourceInfo}`;
        }
      }

      if (event.category === "error") {
        const detail = data.error ? `: ${data.error}` : "";
        return `Fehler (${action})${detail}`;
      }

      return action;
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function estimateTokens(value) {
      return Math.ceil((value || "").length / 4);
    }

    function prettyPrintJson(value) {
      if (value === null || value === undefined) return "";
      const text = typeof value === "string" ? value : JSON.stringify(value);
      try {
        return JSON.stringify(JSON.parse(text), null, 2);
      } catch {
        return text;
      }
    }

    function prettyPrintText(value) {
      if (value === null || value === undefined) return "";
      if (typeof value === "string") return value;
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }

    function showLlmExchangeLoading(event) {
      actionModalTitle.textContent = "LLM-Request Details";
      actionModalTime.textContent = formatActionTime(event?.timestamp);
      actionModalBody.innerHTML = '<div class="modal-field"><p>Lade Details...</p></div>';
      actionModal.classList.remove("hidden");
    }

    function showLlmExchangeUnavailable(event) {
      actionModalTitle.textContent = "LLM-Request Details";
      actionModalTime.textContent = formatActionTime(event?.timestamp);
      actionModalBody.innerHTML = '<div class="modal-field"><p>Keine Details verfuegbar.</p></div>';
      actionModal.classList.remove("hidden");
    }

    function showLlmExchangeError({ event, error }) {
      actionModalTitle.textContent = "LLM-Request Details";
      actionModalTime.textContent = formatActionTime(event?.timestamp);
      actionModalBody.innerHTML = `
        <div class="modal-field">
          <label>Fehler</label>
          <p>${escapeHtml(error || "Unbekannter Fehler")}</p>
        </div>
      `;
      actionModal.classList.remove("hidden");
    }

    function showLlmExchangeDetail({ event, exchange }) {
      const data = event?.data || {};
      const durationMs = exchange?.durationMs ?? data.durationMs;
      const durationText = typeof durationMs === "number" ? `${Math.round(durationMs)} ms` : "-";
      const errorText = exchange?.error || data.error || "-";
      const modelText = exchange?.model || data.model || "-";
      const phaseText = exchange?.phase || "-";
      const attemptsText = Number.isFinite(exchange?.attemptCount) ? exchange.attemptCount : "-";
      const exchangeId = exchange?.exchangeId || data.exchangeId || "-";
      const rawRequest = exchange?.rawRequest || "";
      const rawResponse = exchange?.rawResponse || "";
      const parsedResponse = exchange?.parsedResponse ?? null;
      const requestPretty = prettyPrintJson(rawRequest);
      const responsePretty = prettyPrintJson(rawResponse);
      const requestTokens = estimateTokens(rawRequest);
      const responseTokens = estimateTokens(rawResponse);

      actionModalTitle.textContent = "LLM-Request Details";
      actionModalTime.textContent = formatActionTime(event?.timestamp);

      let bodyHtml = `
        <div class="modal-field">
          <label>Exchange ID</label>
          <p style="font-family: monospace; font-size: 0.8rem;">${escapeHtml(exchangeId)}</p>
        </div>
        <div class="modal-field">
          <label>Modell</label>
          <p>${escapeHtml(modelText)}</p>
        </div>
        <div class="modal-field">
          <label>Phase</label>
          <p>${escapeHtml(phaseText)}</p>
        </div>
        <div class="modal-field">
          <label>Dauer</label>
          <p>${escapeHtml(durationText)}</p>
        </div>
        <div class="modal-field">
          <label>Attempts</label>
          <p>${escapeHtml(attemptsText)}</p>
        </div>
        <div class="modal-field">
          <label>Token (Request)</label>
          <p>${escapeHtml(requestTokens)}</p>
        </div>
        <div class="modal-field">
          <label>Token (Response)</label>
          <p>${escapeHtml(responseTokens)}</p>
        </div>
        <div class="modal-field">
          <label>Fehler</label>
          <p>${escapeHtml(errorText)}</p>
        </div>
        <div class="modal-field">
          <label>Request</label>
          <pre>${escapeHtml(requestPretty || "-")}</pre>
        </div>
        <div class="modal-field">
          <label>Response</label>
          <pre>${escapeHtml(responsePretty || "-")}</pre>
        </div>
      `;

      if (parsedResponse !== null && parsedResponse !== undefined && String(parsedResponse).trim() !== "") {
        bodyHtml += `
          <div class="modal-field">
            <label>Parsed Response</label>
            <pre>${escapeHtml(prettyPrintText(parsedResponse))}</pre>
          </div>
        `;
      }

      actionModalBody.innerHTML = bodyHtml;
      actionModal.classList.remove("hidden");
    }

    function formatLlmRequestItem(event, index) {
      const time = event.timestamp
        ? new Date(event.timestamp).toLocaleTimeString("de-DE")
        : new Date().toLocaleTimeString("de-DE");
      const data = event.data || {};
      const exchangeId = data.exchangeId || "";
      const modelInfo = data.model ? ` ${data.model}` : "";
      const duration = typeof data.durationMs === "number" ? `${Math.round(data.durationMs)} ms` : "n/a";
      const source = data.source ? `Quelle: ${data.source}` : "Quelle: unbekannt";
      const responseInfo = data.hasResponse === false ? "keine Antwort" : "Antwort ok";
      const errorInfo = data.error ? ` • Fehler: ${data.error}` : "";

      return `
        <div class="request-item" data-index="${index}" data-exchange-id="${exchangeId}">
          <div>${time} • LLM-Aufruf${modelInfo}</div>
          <div class="request-meta">${duration} • ${source} • ${responseInfo}${errorInfo}</div>
        </div>
      `;
    }

    function renderLlmRequestHistory(events = []) {
      if (!Array.isArray(events) || events.length === 0) {
        llmRequestView = [];
        llmRequestLog.innerHTML = '<div class="request-item" style="color: #64748b;">Noch keine LLM Requests.</div>';
        return;
      }

      const sorted = [...events].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      llmRequestView = sorted.slice(0, 100);
      llmRequestLog.innerHTML = llmRequestView.map(formatLlmRequestItem).join("");
    }

    function handleAuditEvent(event) {
      if (!event) return;
      addEventToLog(event.category || "event", formatEventMessage(event));

      if (event.category === "error") {
        appendSimLog(formatEventMessage(event));
      }

      if (event.category === "llm") {
        llmRequestEvents = [event, ...llmRequestEvents].slice(0, 100);
        renderLlmRequestHistory(llmRequestEvents);
      }
    }

    function renderEventHistory(events = []) {
      if (!Array.isArray(events) || events.length === 0) {
        eventLog.innerHTML = '<div class="event-item" style="color: #64748b;">Warte auf Events...</div>';
        return;
      }

      const sorted = [...events].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      const items = sorted.slice(0, 100).map((event) => {
        const time = event.timestamp
          ? new Date(event.timestamp).toLocaleTimeString("de-DE")
          : new Date().toLocaleTimeString("de-DE");
        const message = formatEventMessage(event);
        const category = event.category || "event";
        return `
          <div class="event-item">
            <span class="event-time">${time}</span>
            <span class="event-category ${category}">${category}</span>
            ${message}
          </div>
        `;
      });

      eventLog.innerHTML = items.join("");
    }

    function startDurationTimer() {
      stopDurationTimer();
      durationInterval = setInterval(() => {
        if (startTime && !waitingForRoles) {
          // Berechne effektive Laufzeit: Gesamtzeit minus pausierte Zeit
          const effectiveUptime = Date.now() - startTime - totalPausedMs;
          statDuration.textContent = formatDuration(Math.max(0, effectiveUptime));
        }
      }, 1000);
    }

    function stopDurationTimer() {
      if (durationInterval) {
        clearInterval(durationInterval);
        durationInterval = null;
      }
    }

    function setBusy(busy) {
      btnStep.disabled = busy || (!simulationRunning && !simulationPaused);
      btnStart.disabled = busy || simulationRunning || simulationPaused;
      btnPause.disabled = busy || (!simulationRunning && !simulationPaused);
    }

    function applyScenarioDisplay(scenario) {
      if (scenario?.title) {
        activeScenario = scenario;
        scenarioBadge.textContent = scenario.title;
        scenarioBadge.style.display = "inline";
        controlInfo.innerHTML = `<p><strong>${scenario.title}</strong></p>`;
        return;
      }

      activeScenario = null;
      scenarioBadge.style.display = "none";
      controlInfo.innerHTML = (simulationRunning || simulationPaused)
        ? `<p><strong>Freier Modus</strong></p>`
        : '<p style="color: #64748b;">Starten Sie eine Simulation mit Szenario-Auswahl</p>';
    }

    async function hydrateSimulationStatus() {
      try {
        const res = await fetch("/api/sim/status");
        const data = await res.json().catch(() => null);
        if (!data?.ok) return;

        const simStatus = data.simulation || {};
        simulationRunning = !!simStatus.running;
        simulationPaused = !!simStatus.paused;

        // Zeitbasierte Werte laden
        timeRemaining = simStatus.timeRemaining;
        durationMinutes = simStatus.durationMinutes;
        waitingForRoles = !!simStatus.waitingForRoles;
        totalPausedMs = simStatus.totalPausedMs || 0;

        if (simStatus.startTime) {
          startTime = simStatus.startTime;
          // Wenn Simulation gestoppt wurde, zeige die finale Dauer (stoppedAt - startTime)
          if (simStatus.stoppedAt && !simStatus.running && !simStatus.paused) {
            statDuration.textContent = formatDuration(simStatus.stoppedAt - startTime);
            stopDurationTimer();
          } else if (waitingForRoles) {
            // Wenn auf Rollen gewartet wird, zeige die pausierte Zeit (uptime vom Server)
            statDuration.textContent = formatDuration(simStatus.uptime || 0);
            stopDurationTimer(); // Timer stoppen, Zeit ist pausiert
          } else {
            // Simulation läuft oder ist pausiert - Timer weiterlaufen lassen
            // Verwende uptime vom Server (berücksichtigt bereits pausierte Zeit)
            statDuration.textContent = formatDuration(simStatus.uptime || 0);
            startDurationTimer();
          }
        } else {
          startTime = null;
          stopDurationTimer();
          statDuration.textContent = "0:00";
        }

        if (data.audit?.statistics) {
          statistics = { ...statistics, ...data.audit.statistics };
        } else if (typeof simStatus.stepCount === "number") {
          statistics.simSteps = simStatus.stepCount;
        }

        updateStats();
        applyScenarioDisplay(data.scenario || {
          id: simStatus.scenarioId,
          title: simStatus.scenarioTitle
        });
        renderEventHistory(data.events || []);
        llmRequestEvents = (data.events || []).filter(event => event.category === "llm");
        renderLlmRequestHistory(llmRequestEvents);
        updateUI();
      } catch (err) {
        console.error("Fehler beim Laden des Simulationsstatus:", err);
      }
    }

    async function loadRoles() {
      try {
        const onlineRes = await fetch("/api/user/online-roles");
        let onlineRoles = [];

        if (onlineRes.ok) {
          const data = await onlineRes.json();
          onlineRoles = Array.isArray(data?.roles) ? data.roles :
                        Array.isArray(data) ? data : [];
        }

        const onlineSet = new Set(
          onlineRoles.map(r => {
            if (typeof r === "string") return r.toUpperCase();
            if (typeof r?.id === "string") return r.id.toUpperCase();
            return null;
          }).filter(Boolean)
        );

        const alleStabsstellen = [
          { id: "LTSTB", label: "LtStb" },
          { id: "LTSTBSTV", label: "LtStbStv" },
          { id: "S1", label: "S1" },
          { id: "S2", label: "S2" },
          { id: "S3", label: "S3" },
          { id: "S4", label: "S4" },
          { id: "S5", label: "S5" },
          { id: "S6", label: "S6" }
        ];

        roleList.innerHTML = alleStabsstellen.map(rolle => {
          const isActive = onlineSet.has(rolle.id);
          const statusClass = isActive ? "active" : "missing";
          const statusText = isActive ? "besetzt" : "KI";
          const dotClass = isActive ? "active" : "missing";

          return `
            <li class="role-item ${statusClass}">
              <span><span class="role-dot ${dotClass}"></span>${rolle.label}</span>
              <span>${statusText}</span>
            </li>
          `;
        }).join("");

      } catch (err) {
        console.error("Fehler beim Laden der Rollen:", err);
        roleList.innerHTML = `<li class="role-item" style="color: #ef4444;">Fehler: ${err.message}</li>`;
      }
    }

    // ============================================================
    // Chat
    // ============================================================
    function renderChatLog() {
      chatLog.textContent = chatEntries.map(e => `[${e.ts}] ${e.role}: ${e.text}`).join("\n");
    }

    function appendChat(role, text) {
      const entry = { ts: new Date().toLocaleTimeString(), role, text };
      chatEntries.unshift(entry);
      renderChatLog();
      return entry;
    }

    function updateChatEntry(entry, newText) {
      entry.text = newText;
      renderChatLog();
    }

    chatSend.addEventListener("click", async () => {
      const q = (chatInput.value || "").trim();
      if (!q) return;
      chatInput.value = "";
      appendChat("Du", q);

      try {
        const res = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ question: q })
        });
        const contentType = res.headers.get("content-type") || "";

        if (!res.ok || contentType.includes("application/json")) {
          const data = await res.json().catch(() => null);
          if (data?.error === "simulation_running") {
            appendChat(BOT_NAME, "Chat ist nur verfuegbar, wenn die Simulation pausiert ist.");
            return;
          }
          appendChat(BOT_NAME, "Fehler: " + (data?.error || res.statusText || "unbekannt"));
          return;
        }

        const decoder = new TextDecoder('utf-8', { fatal: false, ignoreBOM: true });
        const reader = res.body?.getReader();
        if (!reader) {
          appendChat(BOT_NAME, "(keine Antwort)");
          return;
        }

        const botEntry = appendChat(BOT_NAME, "");
        let accumulated = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          accumulated += decoder.decode(value, { stream: true });
          updateChatEntry(botEntry, accumulated);
        }
        accumulated += decoder.decode();
        updateChatEntry(botEntry, accumulated.trim());
        addEventToLog("user", "Chat-Nachricht gesendet");
      } catch (err) {
        appendChat(BOT_NAME, "Fehler: " + err);
      }
    });

    chatInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        chatSend.click();
      }
    });

    // ============================================================
    // LLM Test
    // ============================================================
    function setLlmBusy(busy) {
      llmSend.disabled = busy;
      llmRefresh.disabled = busy;
      llmModelSelect.disabled = busy;
    }

    function renderGpuStatus(status) {
      if (!status) {
        llmGpuStatus.textContent = "GPU: keine Daten";
        return;
      }

      llmGpuStatus.classList.remove("unavailable");

      if (status.available && Array.isArray(status.gpus) && status.gpus.length) {
        const parts = status.gpus.map(gpu => {
          const util = typeof gpu.utilizationPercent === "number" ? `${gpu.utilizationPercent}%` : "?";
          const memUsed = typeof gpu.memoryUsedMb === "number" ? gpu.memoryUsedMb : "?";
          const memTotal = typeof gpu.memoryTotalMb === "number" ? gpu.memoryTotalMb : "?";
          return `${gpu.name || "GPU"}: ${util} - ${memUsed}/${memTotal} MiB`;
        });
        llmGpuStatus.textContent = `GPU: ${parts.join(" | ")}`;
        return;
      }

      if (status.available) {
        llmGpuStatus.textContent = "GPU: verfuegbar";
        return;
      }

      llmGpuStatus.classList.add("unavailable");
      llmGpuStatus.textContent = `GPU: ${status.error || "nicht verfuegbar"}`;
    }

    async function refreshGpuStatus() {
      try {
        const res = await fetch("/api/llm/gpu");
        const data = await res.json().catch(() => null);
        if (data?.gpuStatus) renderGpuStatus(data.gpuStatus);
        else renderGpuStatus({ available: false, error: "Keine GPU-Daten" });
      } catch (err) {
        renderGpuStatus({ available: false, error: String(err) });
      }
    }

    async function loadLlmModels() {
      setLlmBusy(true);
      llmModelSelect.innerHTML = '<option disabled selected>Modelle werden geladen...</option>';
      llmSend.disabled = true;

      try {
        const res = await fetch("/api/llm/models");
        const data = await res.json();

        if (!res.ok || !data?.ok) throw new Error(data?.error || "Fehler");

        const models = data.models || [];
        llmModelSelect.innerHTML = "";

        if (!models.length) {
          llmModelSelect.innerHTML = '<option disabled selected>Keine Modelle gefunden</option>';
          return;
        }

        for (const model of models) {
          const opt = document.createElement("option");
          opt.value = model;
          opt.textContent = model;
          llmModelSelect.appendChild(opt);
        }
        llmSend.disabled = false;
      } catch (err) {
        llmModelSelect.innerHTML = '<option disabled selected>Laden fehlgeschlagen</option>';
        llmOutput.textContent = "Fehler: " + err;
      } finally {
        setLlmBusy(false);
      }
    }

    async function runLlmTest() {
      const prompt = (llmPrompt.value || "").trim();
      const model = llmModelSelect.value;
      if (!prompt || !model) return;

      setLlmBusy(true);
      llmError.textContent = "";
      llmOutput.textContent = "LLM wird abgefragt...";

      try {
        const res = await fetch("/api/llm/test", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ question: prompt, model })
        });

        const data = await res.json().catch(() => null);
        if (data?.gpuStatus) renderGpuStatus(data.gpuStatus);

        if (!res.ok || !data?.ok) {
          llmError.textContent = data?.error || "Fehler";
          llmOutput.textContent = "Fehler: " + (data?.error || "Unbekannt");
          return;
        }

        llmOutput.textContent = typeof data.answer === "string" ? data.answer : JSON.stringify(data.answer, null, 2);
        addEventToLog("llm", "LLM-Test ausgefuehrt");
      } catch (err) {
        llmError.textContent = String(err);
        llmOutput.textContent = "Fehler: " + err;
      } finally {
        setLlmBusy(false);
      }
    }

    llmRefresh.addEventListener("click", () => {
      loadLlmModels();
      refreshGpuStatus();
    });

    llmSend.addEventListener("click", runLlmTest);

    llmPrompt.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" && (ev.ctrlKey || ev.metaKey)) {
        ev.preventDefault();
        runLlmTest();
      }
    });

    // ============================================================
    // Event Handlers
    // ============================================================
    btnStart.addEventListener("click", showScenarioModal);

    btnStartFree.addEventListener("click", () => {
      hideScenarioModal();
      startSimulation(null);
    });

    btnStartScenario.addEventListener("click", () => {
      hideScenarioModal();
      startSimulation(selectedScenarioId);
    });

    btnCancelModal.addEventListener("click", hideScenarioModal);

    btnStep.addEventListener("click", stepSimulation);
    btnPause.addEventListener("click", togglePauseResume);
    btnEnd.addEventListener("click", endSimulation);

    llmRequestLog.addEventListener("click", async (e) => {
      const item = e.target.closest(".request-item");
      if (!item || item.dataset.index === undefined) return;

      const index = Number(item.dataset.index);
      const event = Number.isFinite(index) ? llmRequestView[index] : null;
      const exchangeId = item.dataset.exchangeId;

      showLlmExchangeLoading(event);

      if (!exchangeId) {
        showLlmExchangeUnavailable(event);
        return;
      }

      try {
        const res = await fetch(`/api/llm/exchange/${encodeURIComponent(exchangeId)}`);
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const payload = await res.json();
        if (!payload?.ok) {
          throw new Error(payload?.error || "Fehler beim Laden");
        }
        showLlmExchangeDetail({ event, exchange: payload.exchange });
      } catch (err) {
        showLlmExchangeError({ event, error: String(err) });
      }
    });

    // ============================================================
    // KI-Aktionen
    // ============================================================
    const actionListEl = document.getElementById("action-list");
    const btnRefreshActions = document.getElementById("btn-refresh-actions");
    const actionCategoryBtns = document.querySelectorAll(".action-category-btn");
    const actionModeBtns = document.querySelectorAll(".action-mode-btn");
    const actionModal = document.getElementById("action-modal");
    const actionModalTitle = document.getElementById("action-modal-title");
    const actionModalTime = document.getElementById("action-modal-time");
    const actionModalBody = document.getElementById("action-modal-body");
    const actionModalClose = document.getElementById("action-modal-close");
    const actionModalCloseBtn = document.getElementById("action-modal-close-btn");

    let currentActionFilter = "";
    let currentActionMode = "applied";
    let llmActions = [];

    const CATEGORY_LABELS = {
      protokoll: "Protokolleintrag",
      aufgabe: "Aufgabe",
      einsatz: "Einsatz"
    };

    const TYPE_LABELS = {
      create: "Angelegt",
      update: "Bearbeitet"
    };

    function formatActionTime(iso) {
      if (!iso) return "";
      const date = new Date(iso);
      return date.toLocaleString("de-DE", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    }

    function getActionTitle(entry) {
      if (!entry) return "";
      const { category, type, data } = entry;
      const typeLabel = TYPE_LABELS[type] || type;

      if (category === "protokoll") {
        const info = data?.information || "";
        return `${typeLabel}: ${info.slice(0, 40)}${info.length > 40 ? "..." : ""}`;
      }
      if (category === "aufgabe") {
        const title = data?.title || "";
        return `${typeLabel}: ${title.slice(0, 40)}${title.length > 40 ? "..." : ""}`;
      }
      if (category === "einsatz") {
        const content = data?.content || "";
        return `${typeLabel}: ${content.slice(0, 40)}${content.length > 40 ? "..." : ""}`;
      }
      return `${typeLabel}: ${CATEGORY_LABELS[category] || category}`;
    }

    function formatPayloadPreview(op) {
      if (!op) return "-";
      const raw = typeof op === "string" ? op : JSON.stringify(op);
      return raw.length > 60 ? `${raw.slice(0, 60)}...` : raw;
    }

    async function loadLlmActions() {
      try {
        const baseUrl = currentActionMode === "rejected"
          ? "/api/llm/ops-verworfen"
          : "/api/llm/action-history";
        const params = new URLSearchParams({ limit: "100" });
        if (currentActionFilter) {
          params.set("category", currentActionFilter);
        }
        const url = `${baseUrl}?${params.toString()}`;

        const res = await fetch(url);
        const data = await res.json();

        llmActions = data.items || [];
        renderActionList();

      } catch (err) {
        console.error("Fehler beim Laden der LLM-Aktionen:", err);
        actionListEl.innerHTML = '<div class="empty-state">Fehler beim Laden der Aktionen</div>';
      }
    }

    function renderActionList() {
      if (llmActions.length === 0) {
        actionListEl.innerHTML = currentActionMode === "rejected"
          ? '<div class="empty-state">Keine verworfenen KI-Aktionen vorhanden</div>'
          : '<div class="empty-state">Keine KI-Aktionen vorhanden</div>';
        return;
      }

      if (currentActionMode === "rejected") {
        actionListEl.innerHTML = llmActions.map((action, index) => `
          <div class="action-item" data-index="${index}">
            <span class="action-badge ${action.category || ""}">${CATEGORY_LABELS[action.category] || action.category || "Unbekannt"}</span>
            <div class="action-content">
              <div class="action-title">${action.kind || "Unbekannter Typ"}</div>
              <div class="action-time">${formatPayloadPreview(action.op)}</div>
              <div class="action-time">Grund: ${action.reason || "-"}</div>
            </div>
            <span class="action-arrow">→</span>
          </div>
        `).join("");
      } else {
        actionListEl.innerHTML = llmActions.map((action, index) => `
          <div class="action-item" data-index="${index}">
            <span class="action-badge ${action.category}">${CATEGORY_LABELS[action.category] || action.category}</span>
            <div class="action-content">
              <div class="action-title">${getActionTitle(action)}</div>
              <div class="action-time">${formatActionTime(action.timestamp)}</div>
            </div>
            <span class="action-arrow">→</span>
          </div>
        `).join("");
      }

      actionListEl.querySelectorAll(".action-item").forEach(item => {
        item.addEventListener("click", () => {
          const index = parseInt(item.dataset.index);
          if (currentActionMode === "rejected") {
            showRejectedActionDetail(llmActions[index]);
          } else {
            showActionDetail(llmActions[index]);
          }
        });
      });
    }

    function showActionDetail(action) {
      if (!action) return;

      const { category, type, data, timestamp } = action;

      actionModalTitle.textContent = `${TYPE_LABELS[type] || type}: ${CATEGORY_LABELS[category] || category}`;
      actionModalTime.textContent = formatActionTime(timestamp);

      let bodyHtml = "";

      if (category === "protokoll") {
        bodyHtml = `
          <div class="modal-field">
            <label>Typ</label>
            <p>${data?.infoTyp || "-"}</p>
          </div>
          <div class="modal-field">
            <label>Von</label>
            <p>${data?.anvon || "-"}</p>
          </div>
          <div class="modal-field">
            <label>An</label>
            <p>${Array.isArray(data?.ergehtAn) ? data.ergehtAn.join(", ") : (data?.ergehtAn || "-")}</p>
          </div>
          <div class="modal-field">
            <label>Information</label>
            <p>${data?.information || "-"}</p>
          </div>
        `;
      } else if (category === "aufgabe") {
        if (type === "create") {
          bodyHtml = `
            <div class="modal-field">
              <label>Titel</label>
              <p>${data?.title || "-"}</p>
            </div>
            <div class="modal-field">
              <label>Typ</label>
              <p>${data?.type || "-"}</p>
            </div>
            <div class="modal-field">
              <label>Verantwortlich</label>
              <p>${data?.responsible || "-"}</p>
            </div>
            <div class="modal-field">
              <label>Beschreibung</label>
              <p>${data?.desc || "-"}</p>
            </div>
          `;
        } else {
          bodyHtml = `
            <div class="modal-field">
              <label>Aufgaben-ID</label>
              <p style="font-family: monospace; font-size: 0.8rem;">${data?.taskId || "-"}</p>
            </div>
            <div class="modal-field">
              <label>Aenderungen</label>
              <pre>${JSON.stringify(data?.changes || {}, null, 2)}</pre>
            </div>
          `;
        }
      } else if (category === "einsatz") {
        if (type === "create") {
          bodyHtml = `
            <div class="modal-field">
              <label>Titel</label>
              <p>${data?.content || "-"}</p>
            </div>
            <div class="modal-field">
              <label>Ort</label>
              <p>${data?.ort || "-"}</p>
            </div>
            <div class="modal-field">
              <label>Beschreibung</label>
              <p>${data?.description || "-"}</p>
            </div>
          `;
        } else {
          bodyHtml = `
            <div class="modal-field">
              <label>Einsatz-ID</label>
              <p style="font-family: monospace; font-size: 0.8rem;">${data?.incidentId || "-"}</p>
            </div>
            <div class="modal-field">
              <label>Aenderungen</label>
              <pre>${JSON.stringify(data?.changes || {}, null, 2)}</pre>
            </div>
          `;
        }
      }

      actionModalBody.innerHTML = bodyHtml;
      actionModal.classList.remove("hidden");
    }

    function showRejectedActionDetail(action) {
      if (!action) return;

      actionModalTitle.textContent = `Verworfen: ${action.kind || "-"}`;
      actionModalTime.textContent = formatActionTime(action.timestamp);

      const bodyHtml = `
        <div class="modal-field">
          <label>Kind</label>
          <p>${action.kind || "-"}</p>
        </div>
        <div class="modal-field">
          <label>Reason</label>
          <p>${action.reason || "-"}</p>
        </div>
        <div class="modal-field">
          <label>Kategorie</label>
          <p>${CATEGORY_LABELS[action.category] || action.category || "-"}</p>
        </div>
        <div class="modal-field">
          <label>Payload</label>
          <pre>${JSON.stringify(action.op || {}, null, 2)}</pre>
        </div>
        <div class="modal-field">
          <label>Meta</label>
          <pre>${JSON.stringify(action.meta || {}, null, 2)}</pre>
        </div>
        <div class="modal-field">
          <label>Active Roles</label>
          <pre>${JSON.stringify(action.activeRoles || [], null, 2)}</pre>
        </div>
      `;

      actionModalBody.innerHTML = bodyHtml;
      actionModal.classList.remove("hidden");
    }

    function closeActionModal() {
      actionModal.classList.add("hidden");
    }

    actionCategoryBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        actionCategoryBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentActionFilter = btn.dataset.filter;
        loadLlmActions();
      });
    });

    actionModeBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        actionModeBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentActionMode = btn.dataset.mode;
        loadLlmActions();
      });
    });

    btnRefreshActions.addEventListener("click", loadLlmActions);

    actionModalClose.addEventListener("click", closeActionModal);
    actionModalCloseBtn.addEventListener("click", closeActionModal);
    actionModal.addEventListener("click", (e) => {
      if (e.target === actionModal) closeActionModal();
    });

    // ============================================================
    // Init
    // ============================================================
    connectSSE();
    hydrateSimulationStatus();
    loadRoles();
    loadLlmModels();
    refreshGpuStatus();
    loadLlmActions();
    updateUI();

    // Rollen alle 15 Sekunden aktualisieren
    setInterval(loadRoles, 15000);

    // LLM-Aktionen alle 30 Sekunden aktualisieren
    setInterval(loadLlmActions, 30000);
  </script>
</body>
</html>
